<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>simmyo_z的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zzz1220.github.io/"/>
  <updated>2023-11-08T06:09:34.190Z</updated>
  <id>https://zzz1220.github.io/</id>
  
  <author>
    <name>zzz1220</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类型体操代码片段</title>
    <link href="https://zzz1220.github.io/posts/5abfc5c1/"/>
    <id>https://zzz1220.github.io/posts/5abfc5c1/</id>
    <published>2023-11-05T13:45:51.000Z</published>
    <updated>2023-11-08T06:09:34.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&quot;TS类型体操&quot;通常是指在TypeScript中使用类型系统的一种技巧，以更好地利用TypeScript的类型检查功能。TypeScript是JavaScript的一个超集，它添加了静态类型定义，使得在开发大型应用程序时更容易进行类型检查和调试。TS类型体操是指利用TypeScript强大的类型系统，通过巧妙的类型定义和使用技巧，以及一些特殊的类型操作，来实现更高级、更复杂的类型检查和类型推断。</p></blockquote><p>最近为了更好的学习ts的类型系统，开始练习类型体操。地址：<br><a href="https://github.com/type-challenges/type-challenges" target="_blank" rel="noopener">https://github.com/type-challenges/type-challenges</a><br>记录一些常用的类型技巧</p><h1>类型体操包括哪些内容？</h1><p>TS类型体操可以包括以下内容：</p><p>类型推断和类型注解：TypeScript允许你在变量、函数参数、函数返回类型等地方进行类型注解，同时也有一定的类型推断机制，可以根据上下文自动推断类型。<br>联合类型和交叉类型：通过联合类型（Union Types）和交叉类型（Intersection Types），可以将多种类型组合在一起，实现更灵活的类型定义。<br>泛型：使用泛型可以在多个地方重用相同的类型，增加代码的灵活性和重用性。<br>条件类型：条件类型是TypeScript中的高级类型，允许根据其他类型来选择其中一种类型定义。<br>映射类型：映射类型允许你从一个现有的类型创建一个新的类型，其中每个属性都可以按照一定的规则转换。<br>类型守卫：使用类型守卫可以在运行时检查类型，帮助你在代码中处理不同的类型情况。<br>keyof 操作符：keyof 操作符用于获取对象类型的所有键，它常用于泛型约束和类型操作。<br>类型操作符：TypeScript提供了一些类型操作符，如keyof、typeof、in等，用于操作和获取类型信息。<br>索引类型：索引类型可以用于访问对象的属性，并保留其类型信息。</p><p>TS类型体操是利用TypeScript强大类型系统的一种技巧和思维方式，它可以帮助开发者更好地利用类型检查来提高代码的可靠性和健壮性。</p><h1>代码片段</h1><p>判断两个类型是否相等</p><pre><code class="language-ts">export type Equal&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends &lt;T&gt;() =&gt; T extends Y ? 1 : 2  ? true  : false</code></pre><p>遍历一个数组的类型</p><pre><code class="language-ts">type TupleToObject&lt;T extends readonly any[]&gt; = {  // 遍历写法：[key in T[number]]  [key in T[number]]: key;};</code></pre><p>遍历联合类型</p><pre><code class="language-ts">// 对于联合类型，extends 语法，会把T中每一个类型都拿出来进行一次判断type MyExclude&lt;T, U&gt; = T extends U ? never : T;// 再来个例子，实现泛型IsUnion&lt;T&gt;，它可以判断T是否为联合类型。T 如果是联合类型，会分成多个子类型和B 比较，然后再判断// B 的所有类型是不是和和T 的子类型一致，这里利用[B] 阻止第二个extends 做类型拆分。type IsUnion&lt;T, B = T&gt; = T extends B ? [B] extends [T] ? false : true : never;// 测试type case1 = IsUnion&lt;string&gt;  // falsetype case2 = IsUnion&lt;string|number&gt;  // truetype case3 = IsUnion&lt;[string|number]&gt;  // false</code></pre><p>字符串类型判断</p><pre><code class="language-ts">// 对于字符串的类型判断，可以用extends 来判断，type TrimsChars = &quot; &quot; | &quot;\n&quot; | &quot;\t&quot;;type TrimLeft&lt;S extends string&gt; = S extends `${TrimsChars}${infer R}`  ? TrimLeft&lt;R&gt;  : S;</code></pre><p>合并数组</p><pre><code class="language-ts">type Concat&lt;T extends any[], U extends any[]&gt; = [...T, ...U]</code></pre><p>生成数组</p><pre><code class="language-ts">type newArr&lt;T extends number, A extends any[] = []&gt; =   A['length'] extends T    ? A    : newArr&lt;T, [...A, '']&gt;type newArr&lt;5&gt; = ['','','','','']    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;quot;TS类型体操&amp;quot;通常是指在TypeScript中使用类型系统的一种技巧，以更好地利用TypeScript的类型检查功能。TypeScript是JavaScript的一个超集，它添加了静态类型定义，使得在开发大型应用程序时更容易进
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="https://zzz1220.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise不经常使用的两个函数</title>
    <link href="https://zzz1220.github.io/posts/90d0eaa2/"/>
    <id>https://zzz1220.github.io/posts/90d0eaa2/</id>
    <published>2023-10-24T07:16:07.000Z</published>
    <updated>2023-11-08T07:30:39.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Promise 前端用的比较多，比如<code>Promise.all</code>, <code>Promise.race</code>, 但是promise两个不太常见的函数<code>Promise.allSettled()</code> 和 <code>Promise.any()</code></p></blockquote><h1>Promise.allSettled()</h1><p>Promise.allSettled() 静态方法将一个 Promise 可迭代对象作为输入，并返回一个单独的 Promise。当所有输入的 Promise 都已敲定时（包括传入空的可迭代对象时），返回的 Promise 将被兑现，并带有描述每个 Promise 结果的对象数组。</p><p>Promise.allSettled() 方法是 promise 并发方法之一。在你有多个不依赖于彼此成功完成的异步任务时，或者你总是想知道每个 promise 的结果时，使用 Promise.allSettled() 。</p><p>相比之下，如果任务相互依赖，或者如果你想在任何 promise 被拒绝时立即拒绝，Promise.all() 返回的 Promise 可能更合适。</p><h1>Promise.any()</h1><p>Promise.any() 静态方法将一个 Promise 可迭代对象作为输入，并返回一个 Promise。当输入的任何一个 Promise 兑现时，这个返回的 Promise 将会兑现，并返回第一个兑现的值。当所有输入 Promise 都被拒绝（包括传递了空的可迭代对象）时，它会以一个包含拒绝原因数组的 AggregateError 拒绝。</p><p>Promise.any() 方法是 Promise 并发方法之一。该方法对于返回第一个兑现的 Promise 非常有用。一旦有一个 Promise 兑现，它就会立即返回，因此不会等待其他 Promise 完成。</p><p>与 Promise.all() 返回一个兑现值数组不同的是，我们只会得到一个兑现值（假设至少有一个 Promise 被兑现）。此方法对于那些如果我们只需要一个 Promise 被兑现，但不在意哪一个被兑现的情况更有益。请注意另一个区别：该方法在接收到空的可迭代对象时会拒绝，因为实际上，该可迭代对象不包含任何兑现的项。你可以将 Promise.any() 和 Promise.all() 与 Array.prototype.some() 和 Array.prototype.every() 进行比较。</p><p>同时，与 Promise.race() 返回第一个敲定（无论是兑现还是拒绝）的值不同的是，该方法返回第一个兑现的值。该方法忽略所有被拒绝的 Promise，直到第一个被兑现的 Promise。</p><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Promise 前端用的比较多，比如&lt;code&gt;Promise.all&lt;/code&gt;, &lt;code&gt;Promise.race&lt;/code&gt;, 但是promise两个不太常见的函数&lt;code&gt;Promise.allSettled()&lt;/code&gt; 和
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="https://zzz1220.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>js创建二维数组</title>
    <link href="https://zzz1220.github.io/posts/f6cbb8a5/"/>
    <id>https://zzz1220.github.io/posts/f6cbb8a5/</id>
    <published>2023-10-21T06:38:21.000Z</published>
    <updated>2023-11-08T07:30:23.108Z</updated>
    
    <content type="html"><![CDATA[<p><code>js</code> 创建二维数组不像<code>java</code>那么直白</p><pre><code class="language-java">// 初始化一个3 * 3 的二维数组int nums[][] = new int[3][3];</code></pre><p>之前我都是这样写的</p><pre><code class="language-javascript">const nums = new Array(3).fill(0).map(() =&gt; new Array(3).fill(0))</code></pre><p>今天看到一个更简洁的写法</p><pre><code class="language-javascript">const nums = Array.from({ length: 3 }, () =&gt; [0,0,0]);</code></pre><p>主要是利用了<code>Array.from</code>这个语法<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a></p><p>Array.from(arrayLike)<br>Array.from(arrayLike, mapFn)<br>Array.from(arrayLike, mapFn, thisArg)</p><p>主要是第一个参数，可以传入一个arrayLike对象，这里可以传<code>{ length: 3 }</code>，比起我之前的写法，看起来更简洁和可读。</p><pre><code class="language-javascript">console.log(Array.from('foo'));// Expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], (x) =&gt; x + x));// Expected output: Array [2, 4, 6]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;js&lt;/code&gt; 创建二维数组不像&lt;code&gt;java&lt;/code&gt;那么直白&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 初始化一个3 * 3 的二维数组
int nums[][] = new int[3][3];
&lt;/co
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>最简单的css排版代码</title>
    <link href="https://zzz1220.github.io/posts/ba9e13e/"/>
    <id>https://zzz1220.github.io/posts/ba9e13e/</id>
    <published>2022-11-20T18:24:45.000Z</published>
    <updated>2023-11-07T06:53:35.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>RT, 几行简单的css 代码让你的排版看起来not bad, ps（这篇post 是用 github Codespaces 提交的）。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">70ch</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">3em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.75</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3em</span> <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d1d1d</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;RT, 几行简单的css 代码让你的排版看起来not bad, ps（这篇post 是用 github Codespaces 提交的）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>几个有意思的智力题</title>
    <link href="https://zzz1220.github.io/posts/b998d6a0/"/>
    <id>https://zzz1220.github.io/posts/b998d6a0/</id>
    <published>2021-07-19T15:06:10.000Z</published>
    <updated>2023-11-07T06:53:35.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了锻炼脑力，避免提前患上老年痴呆症，有必要做一些锻炼思维的智力题。🙂这里不给出答案，答案网上都有，只给一点提示。</p></blockquote><h2 id="1-1000瓶药水找毒药"><a class="header-anchor" href="#1-1000瓶药水找毒药">¶</a>1.1000瓶药水找毒药</h2><p>一道经典题，网上都说是微软面试题，但貌似这几年没见微软考过…</p><p>题目描述如下：</p><p>一共 1000 瓶药水，其中 1 瓶有毒药。<br>已知小白鼠喝毒药一天内死<br>若想在一天内找到毒药，最少需要几只小白鼠？</p><p><strong>关键字：二进制</strong></p><h2 id="2-抢30"><a class="header-anchor" href="#2-抢30">¶</a>2.抢30</h2><p>抢 30 是双人游戏<br>游戏规则是：第一个人喊 “ 1 ”或 “ 2 ”，第二个人要接着往下喊一个或两个数，然后再轮到第一个人。两人轮流进行下去。最后喊 30 的人获胜。问喊数字的最佳策略。</p><p><strong>关键字：bash博弈</strong></p><h2 id="3-三个空瓶子"><a class="header-anchor" href="#3-三个空瓶子">¶</a>3.三个空瓶子</h2><p>有三个空瓶子，一个8L，一个5L，一个3L，目前8L的瓶子装满了牛奶。试问，如果在不浪费一滴水和无刻度的情况下，如何测量出4L的牛奶？</p><p><strong>关键字: 模拟，反推</strong></p><h2 id="4-灯泡开关"><a class="header-anchor" href="#4-灯泡开关">¶</a>4.灯泡开关</h2><p>一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮。</p><p><strong>关键字：模拟，反推，从全灭可以恢复到全亮。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为了锻炼脑力，避免提前患上老年痴呆症，有必要做一些锻炼思维的智力题。🙂这里不给出答案，答案网上都有，只给一点提示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-1000瓶药水找毒药&quot;&gt;&lt;a class=&quot;header-anchor&quot; 
      
    
    </summary>
    
    
      <category term="-智力题" scheme="https://zzz1220.github.io/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>redis常见的使用案例</title>
    <link href="https://zzz1220.github.io/posts/753a7543/"/>
    <id>https://zzz1220.github.io/posts/753a7543/</id>
    <published>2021-05-30T12:15:43.000Z</published>
    <updated>2023-11-07T06:53:35.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>redis</code>除了缓存，还有很多的使用方式，互联网项目的很多功能都是通过<code>redis</code>实现的，今天简单介绍一些。</p></blockquote><h2 id="简单回顾下redis是什么"><a class="header-anchor" href="#简单回顾下redis是什么">¶</a>简单回顾下redis是什么</h2><p><code>Redis</code>是一个使用<code>ANSI C</code>编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。从2015年6月开始，<code>Redis</code>的开发由<code>Redis Labs</code>赞助，而2013年5月至2015年6月期间，其开发由<code>Pivotal</code>赞助。在2013年5月之前，其开发由<code>VMware</code>赞助。根据月度排行网站<code>DB-Engines.com</code>的数据，<code>Redis</code>是最流行的键值对存储数据库。</p><h2 id="redis的特点"><a class="header-anchor" href="#redis的特点">¶</a>redis的特点</h2><ol><li>高性能<br>性能极高 – <code>Redis</code>能读的速度是110000次/s,写的速度是81000次/s 。</li><li>和原生语言无缝的数据结构<br><code>Redis</code>支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li><li>丰富的特性<br>Redis还支持 <code>publish/subscribe</code>, 通知, <code>key</code> 过期等等特性。</li><li>支持持久化<br><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>分布式<br><code>Redis</code>支持数据的备份，即<code>master-slave</code>模式的数据备份。</li><li>高可用<br><code>Redis Sentinel</code> 一个分布式架构，监控各个机器的状态及时作出调整，重新选取主节点。</li></ol><h2 id="五种数据类型和常见用法"><a class="header-anchor" href="#五种数据类型和常见用法">¶</a>五种数据类型和常见用法</h2><h3 id="1-string"><a class="header-anchor" href="#1-string">¶</a>1. <code>string</code></h3><p><code>string</code>在<code>redis</code>里是通过字符数组实现的。你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h4 id="常见的场景"><a class="header-anchor" href="#常见的场景">¶</a>常见的场景</h4><ol><li><code>json</code>字符串储存缓存</li><li><code>string</code>也可以是一个数字，所以也可以作为计数器，使用<code>INCR</code>命令</li><li><code>redis</code>也支持二进制，所以可以当作一个<code>bitmap</code>,把固定长度的bit位储存数据。</li><li>布隆过滤器，一个很长的二进制向量，作为超大的包含关系的查询。详细点击<a href="https://www.huaweicloud.com/articles/cd70d43549f0a4c36641be61780ab66a.html">这里</a></li><li>分布式锁，比较复杂，可以看下<a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">这里</a>。</li></ol><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">APPEND key value</span><br><span class="line">summary: Append a value to a key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">BITCOUNT key [start end]</span><br><span class="line">summary: Count <span class="built_in">set</span> bits <span class="keyword">in</span> a string</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">BITFIELD key [GET <span class="built_in">type</span> offset] [SET <span class="built_in">type</span> offset value] [INCRBY <span class="built_in">type</span> offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br><span class="line">summary: Perform arbitrary bitfield <span class="built_in">integer</span> operations on strings</span><br><span class="line">since: 3.2.0</span><br><span class="line"></span><br><span class="line">BITOP operation destkey key [key ...]</span><br><span class="line">summary: Perform bitwise operations between strings</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">BITPOS key bit [start] [end]</span><br><span class="line">summary: Find first bit <span class="built_in">set</span> or clear <span class="keyword">in</span> a string</span><br><span class="line">since: 2.8.7</span><br><span class="line"></span><br><span class="line">DECR key</span><br><span class="line">summary: Decrement the <span class="built_in">integer</span> value of a key by one</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">DECRBY key decrement</span><br><span class="line">summary: Decrement the <span class="built_in">integer</span> value of a key by the given number</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">GET key</span><br><span class="line">summary: Get the value of a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">GETBIT key offset</span><br><span class="line">summary: Returns the bit value at offset <span class="keyword">in</span> the string value stored at key</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">GETRANGE key start end</span><br><span class="line">summary: Get a substring of the string stored at a key</span><br><span class="line">since: 2.4.0</span><br><span class="line"></span><br><span class="line">GETSET key value</span><br><span class="line">summary: Set the string value of a key and <span class="built_in">return</span> its old value</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">INCR key</span><br><span class="line">summary: Increment the <span class="built_in">integer</span> value of a key by one</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">INCRBY key increment</span><br><span class="line">summary: Increment the <span class="built_in">integer</span> value of a key by the given amount</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">INCRBYFLOAT key increment</span><br><span class="line">summary: Increment the <span class="built_in">float</span> value of a key by the given amount</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">MGET key [key ...]</span><br><span class="line">summary: Get the values of all the given keys</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">MSET key value [key value ...]</span><br><span class="line">summary: Set multiple keys to multiple values</span><br><span class="line">since: 1.0.1</span><br><span class="line"></span><br><span class="line">MSETNX key value [key value ...]</span><br><span class="line">summary: Set multiple keys to multiple values, only <span class="keyword">if</span> none of the keys exist</span><br><span class="line">since: 1.0.1</span><br><span class="line"></span><br><span class="line">PSETEX key milliseconds value</span><br><span class="line">summary: Set the value and expiration <span class="keyword">in</span> milliseconds of a key</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">summary: Set the string value of a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SETBIT key offset value</span><br><span class="line">summary: Sets or clears the bit at offset <span class="keyword">in</span> the string value stored at key</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">SETEX key seconds value</span><br><span class="line">summary: Set the value and expiration of a key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">SETNX key value</span><br><span class="line">summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SETRANGE key offset value</span><br><span class="line">summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">STRLEN key</span><br><span class="line">summary: Get the length of the value stored <span class="keyword">in</span> a key</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-hash"><a class="header-anchor" href="#2-hash">¶</a>2. hash</h3><p>Hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。比如储存用户信息。用户id作为key，姓名，年龄，生日等信息可以维护序列化的对象。</p><h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4><ol><li>存储对象类数据，因此可以存一些结构化的数据，比如购物车，用户基本信息。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HDEL key field [field ...]</span><br><span class="line">summary: Delete one or more <span class="built_in">hash</span> fields</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HEXISTS key field</span><br><span class="line">summary: Determine <span class="keyword">if</span> a <span class="built_in">hash</span> field exists</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HGET key field</span><br><span class="line">summary: Get the value of a <span class="built_in">hash</span> field</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HGETALL key</span><br><span class="line">summary: Get all the fields and values <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HINCRBY key field increment</span><br><span class="line">summary: Increment the <span class="built_in">integer</span> value of a <span class="built_in">hash</span> field by the given number</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line">summary: Increment the <span class="built_in">float</span> value of a <span class="built_in">hash</span> field by the given amount</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">HKEYS key</span><br><span class="line">summary: Get all the fields <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HLEN key</span><br><span class="line">summary: Get the number of fields <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HMGET key field [field ...]</span><br><span class="line">summary: Get the values of all the given <span class="built_in">hash</span> fields</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line">summary: Set multiple <span class="built_in">hash</span> fields to multiple values</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate <span class="built_in">hash</span> fields and associated values</span><br><span class="line">since: 2.8.0</span><br><span class="line"></span><br><span class="line">HSET key field value</span><br><span class="line">summary: Set the string value of a <span class="built_in">hash</span> field</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HSETNX key field value</span><br><span class="line">summary: Set the value of a <span class="built_in">hash</span> field, only <span class="keyword">if</span> the field does not exist</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HSTRLEN key field</span><br><span class="line">summary: Get the length of the value of a <span class="built_in">hash</span> field</span><br><span class="line">since: 3.2.0</span><br><span class="line"></span><br><span class="line">HVALS key</span><br><span class="line">summary: Get all the values <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-list"><a class="header-anchor" href="#3-list">¶</a>3. list</h3><p>list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>可以作为一个简单的消息队列。</p><h4 id="使用场景-v2"><a class="header-anchor" href="#使用场景-v2">¶</a>使用场景</h4><ol><li>简易消息队列，右(左)边进左(右)边出，用来消费队列里的信息。但是ack机制麻烦，复杂场景还是使用专业的mq。</li><li>作为栈使用，支持右(左)边进右(左)边出。</li><li>用于储存线性数据，比如某个人的关注列表。文章点赞的人的id。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BLPOP key [key ...] <span class="built_in">timeout</span></span><br><span class="line">summary: Remove and get the first element <span class="keyword">in</span> a list, or block <span class="keyword">until</span> one is available</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">BRPOP key [key ...] <span class="built_in">timeout</span></span><br><span class="line">summary: Remove and get the last element <span class="keyword">in</span> a list, or block <span class="keyword">until</span> one is available</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">BRPOPLPUSH <span class="built_in">source</span> destination <span class="built_in">timeout</span></span><br><span class="line">summary: Pop a value from a list, push it to another list and <span class="built_in">return</span> it; or block <span class="keyword">until</span> one is available</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">LINDEX key index</span><br><span class="line">summary: Get an element from a list by its index</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">summary: Insert an element before or after another element <span class="keyword">in</span> a list</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">LLEN key</span><br><span class="line">summary: Get the length of a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LPOP key</span><br><span class="line">summary: Remove and get the first element <span class="keyword">in</span> a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line">summary: Prepend one or multiple values to a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LPUSHX key value</span><br><span class="line">summary: Prepend a value to a list, only <span class="keyword">if</span> the list exists</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">LRANGE key start stop</span><br><span class="line">summary: Get a range of elements from a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LREM key count value</span><br><span class="line">summary: Remove elements from a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LSET key index value</span><br><span class="line">summary: Set the value of an element <span class="keyword">in</span> a list by its index</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LTRIM key start stop</span><br><span class="line">summary: Trim a list to the specified range</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">RPOP key</span><br><span class="line">summary: Remove and get the last element <span class="keyword">in</span> a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">RPOPLPUSH <span class="built_in">source</span> destination</span><br><span class="line">summary: Remove the last element <span class="keyword">in</span> a list, prepend it to another list and <span class="built_in">return</span> it</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line">summary: Append one or multiple values to a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">RPUSHX key value</span><br><span class="line">summary: Append a value to a list, only <span class="keyword">if</span> the list exists</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-set"><a class="header-anchor" href="#4-set">¶</a>4. set</h3><p>set 是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。</p><h3 id="使用场景-v3"><a class="header-anchor" href="#使用场景-v3">¶</a>使用场景</h3><ol><li>去重，多台服务可以放在一个set里去重。</li><li>redis 提供了求交集、并集、差集的操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SADD key member [member ...]</span><br><span class="line">summary: Add one or more members to a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SCARD key</span><br><span class="line">summary: Get the number of members <span class="keyword">in</span> a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line">summary: Subtract multiple sets</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br><span class="line">summary: Subtract multiple sets and store the resulting <span class="built_in">set</span> <span class="keyword">in</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SINTER key [key ...]</span><br><span class="line">summary: Intersect multiple sets</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">summary: Intersect multiple sets and store the resulting <span class="built_in">set</span> <span class="keyword">in</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SISMEMBER key member</span><br><span class="line">summary: Determine <span class="keyword">if</span> a given value is a member of a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SMEMBERS key</span><br><span class="line">summary: Get all the members <span class="keyword">in</span> a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SMOVE <span class="built_in">source</span> destination member</span><br><span class="line">summary: Move a member from one <span class="built_in">set</span> to another</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SPOP key [count]</span><br><span class="line">summary: Remove and <span class="built_in">return</span> one or multiple random members from a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line">summary: Get one or multiple random members from a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SREM key member [member ...]</span><br><span class="line">summary: Remove one or more members from a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate Set elements</span><br><span class="line">since: 2.8.0</span><br><span class="line"></span><br><span class="line">SUNION key [key ...]</span><br><span class="line">summary: Add multiple sets</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">summary: Add multiple sets and store the resulting <span class="built_in">set</span> <span class="keyword">in</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-sorted-set"><a class="header-anchor" href="#5-sorted-set">¶</a>5. sorted_set</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 *zadd 命令：*添加元素到集合，元素在集合中存在则更新对应score。set是有序的，根据<code>score</code>排序。</p><h3 id="使用场景-v4"><a class="header-anchor" href="#使用场景-v4">¶</a>使用场景</h3><ol><li>因为自带排序，显示最新的项目列表 ，排行榜相关。</li><li>处理过期项目，比如处理没付款的订单。根据下单时间放进<code>sorted_set</code>，后台任务根据<code>ZRANGE</code>查最近的几条数据，如果过期再回写到数据库。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">summary: Add one or more members to a sorted <span class="built_in">set</span>, or update its score <span class="keyword">if</span> it already exists</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZCARD key</span><br><span class="line">summary: Get the number of members <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZCOUNT key min max</span><br><span class="line">summary: Count the members <span class="keyword">in</span> a sorted <span class="built_in">set</span> with scores within the given values</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZINCRBY key increment member</span><br><span class="line">summary: Increment the score of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">summary: Intersect multiple sorted sets and store the resulting sorted <span class="built_in">set</span> <span class="keyword">in</span> a new key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZLEXCOUNT key min max</span><br><span class="line">summary: Count the number of members <span class="keyword">in</span> a sorted <span class="built_in">set</span> between a given lexicographical range</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by index</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by lexicographical range</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score</span><br><span class="line">since: 1.0.5</span><br><span class="line"></span><br><span class="line">ZRANK key member</span><br><span class="line">summary: Determine the index of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZREM key member [member ...]</span><br><span class="line">summary: Remove one or more members from a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYLEX key min max</span><br><span class="line">summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> between the given lexicographical range</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br><span class="line">summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> within the given indexes</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> within the given scores</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by index, with scores ordered from high to low</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score, with scores ordered from high to low</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">ZREVRANK key member</span><br><span class="line">summary: Determine the index of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span>, with scores ordered from high to low</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">since: 2.8.0</span><br><span class="line"></span><br><span class="line">ZSCORE key member</span><br><span class="line">summary: Get the score associated with the given member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">summary: Add multiple sorted sets and store the resulting sorted <span class="built_in">set</span> <span class="keyword">in</span> a new key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h2><ol><li>Pub/Sub<br>Redis的Pub/Sub非常非常简单，运行稳定并且快速。可以作为发布订阅使用。<br>2.<code>geo</code><br>储存地理坐标数据，用来实现附近的人功能。</li><li>HyperLogLog<br><code>Redis HyperLogLog</code> 是用来做基数统计的算法，<code>HyperLogLog</code> 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<br>在 <code>Redis</code> 里面，每个 <code>HyperLogLog</code> 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64</code> 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;除了缓存，还有很多的使用方式，互联网项目的很多功能都是通过&lt;code&gt;redis&lt;/code&gt;实现的，今天简单介绍一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单回顾下redis是什么&quot;&gt;&lt;a c
      
    
    </summary>
    
    
      <category term="redis" scheme="https://zzz1220.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>跨页面通信的几种方法</title>
    <link href="https://zzz1220.github.io/posts/97160c27/"/>
    <id>https://zzz1220.github.io/posts/97160c27/</id>
    <published>2021-04-14T15:40:07.000Z</published>
    <updated>2023-11-08T07:30:23.113Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原来，跨页面通信有这这么多方法</p></blockquote><h2 id="同源页面之间的通信"><a class="header-anchor" href="#同源页面之间的通信">¶</a>同源页面之间的通信</h2><h3 id="localstorage"><a class="header-anchor" href="#localstorage">¶</a>localStorage</h3><p>这个大家都很熟悉了，但是他还有一个storage事件，之前没接触过<br>当 LocalStorage 变化时，会触发storage事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听storage事件即可收到通知。</p><pre><code class="language-js">// 一个页面监听事件window.addEventListener('storage', function (e) {    if (e.key === 'ctc-msg') {        const data = JSON.parse(e.newValue);        const text = '[receive] ' + data.msg + ' —— tab ' + data.from;        console.log('[Storage I] receive message:', text);    }});// 另外一个页面set数据，这里加上事件戳是因为只有真正改变才会触发storagemydata.st = +(new Date);window.localStorage.setItem('ctc-msg', JSON.stringify(mydata));</code></pre><h3 id="indexeddb"><a class="header-anchor" href="#indexeddb">¶</a>IndexedDB</h3><p>不多介绍了，就是简单的轮询</p><h3 id="service-worker"><a class="header-anchor" href="#service-worker">¶</a>Service Worker</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service workers</a> 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。<br>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：<br>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过postMessage传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：<br>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p><pre><code class="language-JS">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空const sharedWorker = new SharedWorker('../util.shared.js', 'ctc');</code></pre><p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p><pre><code class="language-js">/* ../util.shared.js: Shared Worker 代码 */let data = null;self.addEventListener('connect', function (e) {    const port = e.ports[0];    port.addEventListener('message', function (event) {        // get 指令则返回存储的消息数据        if (event.data.get) {            data &amp;&amp; port.postMessage(data);        }        // 非 get 指令则存储该消息数据        else {            data = event.data;        }    });    port.start();});</code></pre><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p><pre><code class="language-js">// 定时轮询，发送 get 指令的消息setInterval(function () {    sharedWorker.port.postMessage({get: true});}, 1000);// 监听 get 消息的返回数据sharedWorker.port.addEventListener('message', (e) =&gt; {    const data = e.data;    const text = '[receive] ' + data.msg + ' —— tab ' + data.from;    console.log('[Shared Worker] receive message:', text);}, false);sharedWorker.port.start();</code></pre><p>最后，当要跨页面通信时，只需给 Shared Worker postMessage即可：</p><pre><code class="language-js">sharedWorker.port.postMessage(mydata);</code></pre><p>注意，如果使用addEventListener来添加 Shared Worker 的消息监听，需要显式调用MessagePort.start方法，即上文中的sharedWorker.port.start()；如果使用onmessage绑定监听则不需要。</p><h3 id="broadcast-channel"><a class="header-anchor" href="#broadcast-channel">¶</a>BroadCast Channel</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API" target="_blank" rel="noopener">Broadcast Channel API</a> 可以实现同 源 下浏览器不同窗口，Tab页，frame或者 iframe 下的 浏览器上下文 (通常是同一个网站下不同的页面)之间的简单通讯。</p><p>简单的api展示：</p><pre><code class="language-js">// 连接到广播频道,在多个页面注册同一个频道var bc = new BroadcastChannel('test_channel');// 发送简单消息的示例bc.postMessage('This is a test message.');// 简单示例，用于将事件打印到控制台bc.onmessage = function (ev) { console.log(ev); }// 断开频道连接bc.close()</code></pre><h2 id="非同源页面之间的通信"><a class="header-anchor" href="#非同源页面之间的通信">¶</a>非同源页面之间的通信</h2><h3 id="利用中间iframe作为brideg"><a class="header-anchor" href="#利用中间iframe作为brideg">¶</a>利用中间iframe作为brideg</h3><p>使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定origin来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<a href="http://sample.com/bridge.html%EF%BC%89%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B" target="_blank" rel="noopener">http://sample.com/bridge.html），而这些</a> iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p><pre><code class="language-js">/* 业务页面代码 */window.addEventListener('message', function (e) {    // …… do something});/* 业务页面代码发信息 */window.frames[0].window.postMessage(mydata, '*');</code></pre><h3 id="利用websocket"><a class="header-anchor" href="#利用websocket">¶</a>利用websocket</h3><p>利用后端新开一个websocket服务，多个页面都接受服务端的推送，也可以实现同步状态。</p><hr><p>原文地址，本文稍作删改：<br><a href="https://juejin.cn/post/6844903811232825357" target="_blank" rel="noopener">https://juejin.cn/post/6844903811232825357</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原来，跨页面通信有这这么多方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;同源页面之间的通信&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#同源页面之间的通信&quot;&gt;¶&lt;/a&gt;同源页面之间的通信&lt;/h2&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch使用</title>
    <link href="https://zzz1220.github.io/posts/5e47ac86/"/>
    <id>https://zzz1220.github.io/posts/5e47ac86/</id>
    <published>2021-04-11T15:38:41.000Z</published>
    <updated>2023-11-07T06:53:35.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一次将千万级别的数据库表迁移到Elasticsearch 的过程</p></blockquote><h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>我们有一张千万级别，并且每天都新增将近万条数据，更新也在十几万的业务表，这个业务表可以说是我们的核心业务，因为历史问题，表字段除了基本的字段外，还存了json， 一个字符串可代表多业务， 甚至存了二进制的对象， 同时，我们的运营页面需要根据将近20个查询条件对这个表进行查询，一方面因为数据量大，多个查询条件组合起来，查出数据有时也要十几秒，甚至在一些极端情况下，页面直接超时，用户体验很不好，另一方面，有些字段隐藏在json内部，或者二进制的对象里面，限制了其作为查询条件。</p><h2 id="预研"><a class="header-anchor" href="#预研">¶</a>预研</h2><p>于是我花了两天的时间了解了Elasticsearch 是什么，可以做什么，大概的操作步骤，查询api，以及配套的生态，又花了一天在测试环境搭建了一套elk，就开始了迁移的测试。<br>ps：在这里说明一下<br>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。<br>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志<br>elk当然就是这三部分的组合了。</p><h2 id="用logstash-同步数据"><a class="header-anchor" href="#用logstash-同步数据">¶</a>用logstash 同步数据</h2><p>logstash 本身的配置也不复杂，分为<code>input</code>，<code>filter</code>，<code>output</code> 三部分。<br><code>input</code> 和 <code>output</code>支持各种插件。<br>比如<code>input</code> 支持 <code>mysql</code>，<code>file</code>，<code>http</code>，等等，最新的<code>input</code> 甚至支持<code>Twitter </code>。<br><code>output</code> 支持 <code>elasticsearch</code>，<code>email</code>，<code>rabbitmq</code>等等。<br>查看所有支持的插件可以点击<a href="https://www.elastic.co/guide/en/logstash/7.12/introduction.html">这里</a></p><p>这一步本来是很简单的，因为logstash 本身就支持同步mysql数据到es，只需要简单的配置，加上json的中间filter，就可以完成了，但是就是二进制的数据对象要解析出来有点麻烦，还好logstash支持用ruby作为脚本，于是就需要编写一个ruby脚本，把从mysql里读出来的二进制转化成对象，我们存的二进制是protobuf转化的对象，因此，需要用一个protobuf的库 把二进制转成ruby对象，然后在解析这个对象，分割成不同的字段存入es。<br>首先，我从内部的平台，下载了原始的protobuf文件，然后在公司的编译机上，便成ruby的class文件，但是怎么从二进制解码到对象呢？我又翻看了下logstash的文档，发现他有一个codec的插件是直接支持解码pb对象的，但是这个插件只支持每次解析一行，但是我从mysql读出来的数据，是一行sql插叙结果，里面只有几个字段是二进制的，于是我找到了这个插件<code>logstash-codec-protobuf</code>的github<a href="https://github.com/logstash-plugins/logstash-codec-protobuf">地址</a>，简单看了下源码和<code>api</code>，源码不多加上注释也才700多行，虽然没学过ruby但也大概看出来一些逻辑，看了下他的依赖，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;logstash/codecs/base&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;logstash/util/charset&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;google/protobuf&#x27;</span> <span class="comment"># for protobuf3</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;protocol_buffers&#x27;</span> <span class="comment"># https://github.com/codekitchen/ruby-protocol-buffers, for protobuf2</span></span><br></pre></td></tr></table></figure><p>主要起作用的应该是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;google/protobuf&#x27;</span> <span class="comment"># for protobuf3</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;protocol_buffers</span></span><br></pre></td></tr></table></figure><p>整个代码是一个面向对象的语法， 定义了一个class</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogStash::Codecs::Protobuf</span> &lt; <span class="title class_ inherited__">LogStash::Codecs::Base</span></span><br></pre></td></tr></table></figure><p>里面有<code>register</code>,<code>decode</code>,<code>encode</code> 等方法，看来起作用的就是<code>decode</code> 了，马上拿来放在脚本里面跑了一下，成功从二进制解析得到了ruby对象。</p><p>接下来就简单了，注意细节，对照字段开始同步。大概花了25个小时，就把所有的数据同步到了es,增量的数据，我用<code>updatetime</code>作为查询条件更新。</p><h2 id="用php客户端查询数据"><a class="header-anchor" href="#用php客户端查询数据">¶</a>用php客户端查询数据</h2><p>最后，我用php客户端，通过http调用的形式，使用es查询语法，对数据进行查询，果然快了很多，复杂的查询条件，也能在1s左右查询出来。</p><p>这里要说明的是<code>kibana</code>里面有个devtool的页面，可以在里面写查询语句验证结果，使用起来十分方便。</p><h2 id="遇到的坑"><a class="header-anchor" href="#遇到的坑">¶</a>遇到的坑</h2><p>主要是分页查询的时候，很大的数据量下不能以一般的查询语法，即from to 这种，因为在深度分页的情况下，这种使用方式效率是非常低的，比如from = 5000, size=10， es 需要在各个分片上匹配排序并得到5000*10条有效数据，然后在结果集中取最后10条数据返回。</p><p>我们就遇到了这个问题，先把<code>max_result_window </code>调大了一些，后来用深度分页代替：<br>es 提供了 <code>Scroll API</code> 的方式进行分页读取。原理上是对某次查询生成一个游标 scroll_id ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。scroll_id 的生成可以理解为建立了一个临时的历史快照，在此之后的增删改查等操作不会影响到这个快照的结果。<br>但是这个也不允许随机跳页，适合类似微博那种下拉翻页的场景。</p><p>ps: 关于深度分页优化可以看下<a href="https://juejin.cn/post/6850037275456339975">这里</a></p><h2 id="elk很复杂的"><a class="header-anchor" href="#elk很复杂的">¶</a>elk很复杂的</h2><p>虽然基本符合了使用场景，但是关于elk我感觉还是只了解了皮毛，如何优化，怎么关联查询，怎么设置索引结构更高效，更复杂的查询语句，这些都还没接触到。<br>ps: 网上很多关于性能优化的文章，比如<a href="https://zhuanlan.zhihu.com/p/67362440">这篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录一次将千万级别的数据库表迁移到Elasticsearch 的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;¶&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;我们有一张千万
      
    
    </summary>
    
    
      <category term="Elasticsearch" scheme="https://zzz1220.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>2道算法题的优化过程</title>
    <link href="https://zzz1220.github.io/posts/7e570359/"/>
    <id>https://zzz1220.github.io/posts/7e570359/</id>
    <published>2021-04-08T15:38:41.000Z</published>
    <updated>2023-11-08T07:30:23.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近刷了那么多的算法,感觉自己刚刚有点进步,又被两道简单题搞晕了🙃🙃,彻底暴露了自己对时间复杂度掌握不足的遗漏,因此在这里记录下优化的过程.</p></blockquote><h3 id="第一题"><a class="header-anchor" href="#第一题">¶</a>第一题</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：</p><p>输入：nums = [1,1,1,2,2,3]<br>输出：5, nums = [1,1,2,2,3]<br>解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums = [0,0,1,1,1,1,2,3,3]<br>输出：7, nums = [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。<br>一看到题目,觉得不难,马上开始写代码,就模拟整个过程,几分钟搞定.</p><pre><code class="language-JavaScript">var removeDuplicates = function(nums) {        let len = nums.length    let last = nums[len-1]    let count = 1    for(let i = nums.length-2;i&gt;=0;i--) {        if(nums[i] === last) {            count++            if(count&gt;2) {                len--                for(let j = i;j&lt;len;j++) {                    nums[j] = nums[j+1]                }            }        }else {            count = 1            last = nums[i]        }       }    return len};</code></pre><p>刚好这几天几个同事都在打卡每日一题,我们交流了一下,我把自己的代码给同事看了看,一个同事立马说,你这个时间复杂度太高了,我仔细看了看代码,确实,循环里面移动数组,大概复杂度O(n^2).</p><p>听了同事的的解法,我顿悟了,原来双指针就好了,快慢指针,慢指针保持长度,快指针每次+1用来检查后面的元素,遇到不同的元素,并且前方已经出现了两个重复的,就覆盖前方慢指针的元素,然后慢指针继续+1</p><p>下面是代码:</p><pre><code class="language-JavaScript">var removeDuplicates = function(nums) {    let n = nums.length    if(n&lt;2) {        return n    }    let slow = 2    let fast = 2        while(fast&lt;n) {        if(nums[slow-2] !== nums[fast]) {            nums[slow] = nums[fast]            slow++        }        fast++    }        return slow};</code></pre><p>这样时间复杂度就被优化到了O(n),只遍历了一边.<br>经过自己的测试,在长度为999999,三个一组相同的数组的运行测试下,第二种花费大概3ms,而第一种,居然用了100000+ms,相差了3万倍!!!🤯 🤯 🤯 🤯 🤯</p><h3 id="第二题"><a class="header-anchor" href="#第二题">¶</a>第二题</h3><p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1<br>示例 1：</p><p>输入：nums = [2,5,3,5], target = 6</p><p>输出：1</p><p>解释：预算内仅能购买 nums[0] 与 nums[2]。</p><p>示例 2：</p><p>输入：nums = [2,2,1,9], target = 10</p><p>输出：4</p><p>解释：符合预算的采购方案如下：<br>nums[0] + nums[1] = 4<br>nums[0] + nums[2] = 3<br>nums[1] + nums[2] = 3<br>nums[2] + nums[3] = 10</p><p>第一眼看到这个题,心想这么简单的吗?<br>立马又是双层循环遍历一边,果不其然超时了,一看给的测试用例,长度 <code>2 &lt;= nums.length &lt;= 10^5</code><br>考虑到没有负数,于是加了个判断第一个数的长度是否大于target,然而还是超时.<br>想了想,先排下顺序吧,然后二分找到小于target的部分,在这个范围内判断,后来又想,如果target很大怎么办?不还是要遍历很多次吗?<br>想啊想,死掉n个脑细胞,m根头发后,我明白了,在一个顺序的数组里,如果下标i和下标j满足小于target,那么i和其他小于j的其他组合都满足,这个个数是(j-i)个,然后i++继续判断就行了,如果大于target了,就大数的下标,j 向左移动j-- 就行了. 想明白后,才发现已经过去1个小时了.马上动手写代码</p><pre><code class="language-JavaScript">var purchasePlans = function(nums, target) {    const MOD = 1000000007    nums.sort((a,b) =&gt; a-b)    let i = 0    let  j = nums.length-1    let res = 0    while(i&lt;j) {        if(nums[i] + nums[j] &lt;= target) {            res+=j-i            res = res%MOD            i++        }else {            j--        }    }    return res};</code></pre><p>这样就O(n)了,同时,不要忘了模MOD.</p><p>注意时间复杂度,不要再写低效率的代码了💪💪💪💪💪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近刷了那么多的算法,感觉自己刚刚有点进步,又被两道简单题搞晕了🙃🙃,彻底暴露了自己对时间复杂度掌握不足的遗漏,因此在这里记录下优化的过程.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第一题&quot;&gt;&lt;a class=&quot;header-anc
      
    
    </summary>
    
    
      <category term="算法" scheme="https://zzz1220.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容性问题</title>
    <link href="https://zzz1220.github.io/posts/fe80343/"/>
    <id>https://zzz1220.github.io/posts/fe80343/</id>
    <published>2021-04-07T13:23:44.000Z</published>
    <updated>2023-11-08T07:32:54.896Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个记录日常结局浏览器兼容问题的备忘录</p></blockquote><ol><li>如何查看某个javaScript 对象或者css 属性的兼容性</li></ol><p>到MND搜索需要查看的内容,页面底部提供一份不同平台(比如PC端,手机端,node端)以及不同浏览器进行和其各个历史版本的兼容表格,可以很直观的看到你要用的技术是否支持业务覆盖的浏览器或者平台.</p><ol start="2"><li>浏览器强制用webkit内核<br>国内部分双核浏览器如：360极速浏览器、搜狗浏览器、百度浏览器等等，这些浏览器都号称拥有两个内核，用户可以根据需要自由切换。双核浏览器的2个内个分别为极速内核（webkit内核），兼容内核（trident内核）。使用极速内核浏览器会按照w3c的新标准渲染页面，其结果是渲染速度更快，规范性更好。而兼容内核也并非一无是处，国内很多政府、银行类网站在编写之初考虑了兼容旧版本ie的trident内核，其代码并非为w3c规范的标准，而是浏览器厂商自定义的模式，这类网站则必须使用兼容模式打开，如果使用极速模式打开就会产生布局错乱等问题。</li></ol><p>可以用下面的标签强制浏览器使用极速内核:</p><meta name="renderer" content="webkit"><p>也可以使用兼容的写法:</p><meta name="renderer" content="webkit|ie-comp|ie-stand">这里会根据先后顺序,启用支持的内核,不支持也不会<ol start="3"><li>重置样式<br>不同的浏览器之间基本样式很不一样，比如IE浏览器使用ie盒子模型，现代浏览器大多使用标准盒子模型。他们之间的宽度计算很不一样。<br>这个时候就需要用reset.css重置一下样式了</li></ol><pre><code class="language-css">@charset &quot;utf-8&quot;;/* CSS Document */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td {    margin: 0;    padding: 0;    border: 0;    outline: 0;    font-size: 100%;    vertical-align: baseline;    background: transparent;}body {    line-height: 1;}ol, ul {    list-style: none;}blockquote, q {    quotes: none;}blockquote:before, blockquote:after,q:before, q:after {    content: '';    content: none;}/* remember to define focus styles! */:focus {    outline: 0;}/* remember to highlight inserts somehow! */ins {    text-decoration: none;}del {    text-decoration: line-through;}/* tables still need 'cellspacing=&quot;0&quot;' in the markup */table {    border-collapse: collapse;    border-spacing: 0;}/* 清除浮动 */.clearfloat:after{display:block;clear:both;content:&quot;&quot;;visibility:hidden; height:0;} .clearfloat{zoom:1} </code></pre><ol start="4"><li>浏览器类型判断</li></ol><pre><code class="language-JavaScript">// 浏览器类型判断function browserType () {    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器    var isIE = window.ActiveXObject || &quot;ActiveXObject&quot; in window    var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1; //判断是否IE的Edge浏览器    var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器    var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器    var isChrome = userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; !isEdge; //判断Chrome浏览器    if (isIE) {        var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);        reIE.test(userAgent);        var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);        if (userAgent.indexOf('MSIE 6.0') != -1) {            return &quot;IE6&quot;;        } else if (fIEVersion == 7) {            return &quot;IE7&quot;;        }        else if (fIEVersion == 8) {            return &quot;IE8&quot;;        }        else if (fIEVersion == 9) {            return &quot;IE9&quot;;        }        else if (fIEVersion == 10) {            return &quot;IE10&quot;;        }        else if (userAgent.toLowerCase().match(/rv:([\d.]+)\) like gecko/)) {            return &quot;IE11&quot;;        }        else {            return &quot;0&quot;        }//IE版本过低    }    if (isFF) {        return &quot;FF&quot;;    }    if (isOpera) {        return &quot;Opera&quot;;    }    if (isSafari) {        return &quot;Safari&quot;;    }    if (isChrome) {        return &quot;Chrome&quot;;    }    if (isEdge) {        return &quot;Edge&quot;;    }}</code></pre><ol start="5"><li>html if 判断浏览器ie版本</li></ol><pre><code class="language-html">&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</code></pre><p>~~未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个记录日常结局浏览器兼容问题的备忘录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如何查看某个javaScript 对象或者css 属性的兼容性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到MND搜索需要查看的内容,页面底部提供一份不同平台(比如PC
      
    
    </summary>
    
    
      <category term="html5" scheme="https://zzz1220.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>promiseA+</title>
    <link href="https://zzz1220.github.io/posts/d721f59f/"/>
    <id>https://zzz1220.github.io/posts/d721f59f/</id>
    <published>2021-04-06T15:36:55.000Z</published>
    <updated>2023-11-08T07:30:23.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript Promise A+ 规范</p></blockquote><p>译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p><p>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</p><p>译文术语:</p><p>解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</p><p>拒绝（reject）：指一个 promise 失败时进行的一系列操作。</p><p>终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</p><p>据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</p><p>实现:</p><pre><code class="language-JavaScript">/** * Promise 实现 遵循promise/A+规范 * Promise/A+规范译文: * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4 */// promise 三个状态const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(excutor) {    let that = this; // 缓存当前promise实例对象    that.status = PENDING; // 初始状态    that.value = undefined; // fulfilled状态时 返回的信息    that.reason = undefined; // rejected状态时 拒绝的原因    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数    that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数    function resolve(value) { // value成功态时接收的终值        if (value instanceof Promise) {            return value.then(resolve, reject);        }        // 为什么resolve 加setTimeout?        // 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.        // 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。        setTimeout(() =&gt; {            // 调用resolve 回调对应onFulfilled函数            if (that.status === PENDING) {                // 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject)                that.status = FULFILLED;                that.value = value;                that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));            }        });    }    function reject(reason) { // reason失败态时接收的拒因        setTimeout(() =&gt; {            // 调用reject 回调对应onRejected函数            if (that.status === PENDING) {                // 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject)                that.status = REJECTED;                that.reason = reason;                that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));            }        });    }    // 捕获在excutor执行器中抛出的异常    // new Promise((resolve, reject) =&gt; {    //     throw new Error('error in excutor')    // })    try {        excutor(resolve, reject);    } catch (e) {        reject(e);    }}/** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 *//** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param  {promise} promise2 promise1.then方法返回的新的promise对象 * @param  {[type]} x         promise1中onFulfilled的返回值 * @param  {[type]} resolve   promise2的resolve方法 * @param  {[type]} reject    promise2的reject方法 */function resolvePromise(promise2, x, resolve, reject) {    if (promise2 === x) { // 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错        return reject(new TypeError('循环引用'));    }    let called = false; // 避免多次调用    // 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无）    if (x instanceof Promise) { // 获得它的终值 继续resolve        if (x.status === PENDING) { // 如果为等待态需等待直至 x 被执行或拒绝 并解析y值            x.then(y =&gt; {                resolvePromise(promise2, y, resolve, reject);            }, reason =&gt; {                reject(reason);            });        } else { // 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise            x.then(resolve, reject);        }        // 如果 x 为对象或者函数    } else if (x != null &amp;&amp; ((typeof x === 'object') || (typeof x === 'function'))) {        try { // 是否是thenable对象（具有then方法的对象/函数）            let then = x.then;            if (typeof then === 'function') {                then.call(x, y =&gt; {                    if (called) return;                    called = true;                    resolvePromise(promise2, y, resolve, reject);                }, reason =&gt; {                    if (called) return;                    called = true;                    reject(reason);                })            } else { // 说明是一个普通对象/函数                resolve(x);            }        } catch (e) {            if (called) return;            called = true;            reject(e);        }    } else {        resolve(x);    }}/** * [注册fulfilled状态/rejected状态对应的回调函数] * @param  {function} onFulfilled fulfilled状态时 执行的函数 * @param  {function} onRejected  rejected状态时 执行的函数 * @return {function} newPromsie  返回一个新的promise对象 */Promise.prototype.then = function (onFulfilled, onRejected) {    const that = this;    let newPromise;    // 处理参数默认值 保证参数后续能够继续执行    onFulfilled =        typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;    onRejected =        typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; {            throw reason;        };    // then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ?    // 原因:    // 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout    // 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected    // 其二 2.2.6规范 也是resolve函数里加setTimeout的原因    // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行    // 如下面这种情景 多次调用p1.then    // p1.then((value) =&gt; { // 此时p1.status 由pedding状态 =&gt; fulfilled状态    //     console.log(value); // resolve    //     // console.log(p1.status); // fulfilled    //     p1.then(value =&gt; { // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行    //         console.log(value); // 'resolve'    //     });    //     console.log('当前执行栈中同步代码');    // })    // console.log('全局执行栈中同步代码');    //    if (that.status === FULFILLED) { // 成功态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onFulfilled(that.value);                    resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值                } catch (e) {                    reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);                }            });        })    }    if (that.status === REJECTED) { // 失败态        return newPromise = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                try {                    let x = onRejected(that.reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });        });    }    if (that.status === PENDING) { // 等待态        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中        return newPromise = new Promise((resolve, reject) =&gt; {            that.onFulfilledCallbacks.push((value) =&gt; {                try {                    let x = onFulfilled(value);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });            that.onRejectedCallbacks.push((reason) =&gt; {                try {                    let x = onRejected(reason);                    resolvePromise(newPromise, x, resolve, reject);                } catch (e) {                    reject(e);                }            });        });    }};/** * Promise.all Promise进行并行处理 * 参数: promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。 */Promise.all = function (promises) {    return new Promise((resolve, reject) =&gt; {        let done = gen(promises.length, resolve);        promises.forEach((promise, index) =&gt; {            promise.then((value) =&gt; {                done(index, value)            }, reject)        })    })}function gen(length, resolve) {    let count = 0;    let values = [];    return function (i, value) {        values[i] = value;        if (++count === length) {            console.log(values);            resolve(values);        }    }}/** * Promise.race * 参数: 接收 promise对象组成的数组作为参数 * 返回值: 返回一个Promise实例 * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快) */Promise.race = function (promises) {    return new Promise((resolve, reject) =&gt; {        promises.forEach((promise, index) =&gt; {            promise.then(resolve, reject);        });    });}// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常Promise.prototype.catch = function (onRejected) {    return this.then(null, onRejected);}Promise.resolve = function (value) {    return new Promise(resolve =&gt; {        resolve(value);    });}Promise.reject = function (reason) {    return new Promise((resolve, reject) =&gt; {        reject(reason);    });}/** * 基于Promise实现Deferred的 * Deferred和Promise的关系 * - Deferred 拥有 Promise * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject） * *参考jQuery.Deferred *url: http://api.jquery.com/category/deferred-object/ */Promise.deferred = function () { // 延迟对象    let defer = {};    defer.promise = new Promise((resolve, reject) =&gt; {        defer.resolve = resolve;        defer.reject = reject;    });    return defer;}/** * Promise/A+规范测试 * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */try {    module.exports = Promise} catch (e) {}</code></pre><p>来源:<br><a href="https://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">https://www.ituring.com.cn/article/66566</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;JavaScript Promise A+ 规范&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue3-new-feature</title>
    <link href="https://zzz1220.github.io/posts/20a24eb5/"/>
    <id>https://zzz1220.github.io/posts/20a24eb5/</id>
    <published>2020-12-29T07:47:59.000Z</published>
    <updated>2023-11-07T06:53:35.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结一下最近一段时间学习 vue3 的收获</p></blockquote><h2 id="功能方面"><a class="header-anchor" href="#功能方面">¶</a>功能方面</h2><h4 id="Composition-API-组合API"><a class="header-anchor" href="#Composition-API-组合API">¶</a>Composition API (组合API)</h4><p>Composition API 的灵感来自于 React Hooks ，是比 mixin 更强大的存在。它可以提高代码逻辑的可复用性，从而实现与模板的无关性；同时函数式的编程使代码的可压缩性更强。另外，把 Reactivity 模块独立开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。<br>官方例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鼠标位置侦听逻辑 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">update</span> = e =&gt; &#123;</span><br><span class="line">            state.<span class="property">x</span> = e.<span class="property">pageX</span></span><br><span class="line">            state.<span class="property">y</span> = e.<span class="property">pageY</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">toRefs</span>(state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，就是把相关的逻辑单独拿出来提高代码复用</p><h4 id="全局挂载-配置API更改"><a class="header-anchor" href="#全局挂载-配置API更改">¶</a>全局挂载/配置API更改</h4><p>vue2 使用 new Vue 创建实例，通过全局设置config配置vue的可选配置。<br>vue3 使用 createApp 定义的某个 Vue 程序。它可以使你的代码更易于理解，并且不易出现由第三方插件引发的意外问题。目前，如果某些第三方解决方案正在修改 Vue 对象，那么它可能会以意想不到的方式（尤其是全局混合）影响你的程序，而 Vue 3 则没有这个问题.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="property">config</span>.<span class="property">ignoredElements</span> = [<span class="regexp">/^app-/</span>]</span><br><span class="line">app.<span class="title function_">use</span>(<span class="comment">/* ... */</span>)</span><br><span class="line">app.<span class="title function_">mixin</span>(<span class="comment">/* ... */</span>)</span><br><span class="line">app.<span class="title function_">component</span>(<span class="comment">/* ... */</span>)</span><br><span class="line">app.<span class="title function_">directive</span>(<span class="comment">/* ... */</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Fragments-片段"><a class="header-anchor" href="#Fragments-片段">¶</a>Fragments(片段)</h4><p>在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React中的Fragment组件是一样的）。</p><h4 id="Suspense"><a class="header-anchor" href="#Suspense">¶</a>Suspense</h4><p>同样的，这和React中的Supense是一样的。Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Suspended-component</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">    Loading...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="v-model-支持多个"><a class="header-anchor" href="#v-model-支持多个">¶</a>v-model 支持多个</h4><p>在 3.x 版本中，在自定义组件上使用 v-model 相当于传递了一个 modelValue 属性以及触发一个 update:modelValue 事件。<br>如果要改变绑定的属性名，只需要给 v-model 传递一个参数就好了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">KyrieInput</span> <span class="attr">v-model:title</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">KyrieInput</span> <span class="attr">:title</span>=<span class="string">&quot;name&quot;</span> @<span class="attr">update:title</span>=<span class="string">&quot;name = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个写法还彻底代替了 .sync 修饰符，并且支持统一组件绑定多个 v-model</p><h4 id="Portals"><a class="header-anchor" href="#Portals">¶</a>Portals</h4><p>Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p><h2 id="实现逻辑重大更改"><a class="header-anchor" href="#实现逻辑重大更改">¶</a>实现逻辑重大更改</h2><h4 id="响应式原理"><a class="header-anchor" href="#响应式原理">¶</a>响应式原理</h4><p>Object.defineProperty -&gt; Proxy<br>Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。</p><p>javascript引擎在解析的时候希望对象的结构越稳定越好，如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。</p><p>同时，有了Proxy，就不用考虑新增属性的响应行为了，是时候要跟$set说声再见了。</p><h2 id="性能方面"><a class="header-anchor" href="#性能方面">¶</a>性能方面</h2><p>双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快，且消除了之前存在的警告；<br>重写了 Vdom ，突破了 Vdom 的性能瓶颈<br>进行了模板编译的优化<br>进行了更加高效的组件初始化</p><h4 id="支持tree-shaking-更加解耦的代码结构"><a class="header-anchor" href="#支持tree-shaking-更加解耦的代码结构">¶</a>支持tree-shaking , 更加解耦的代码结构</h4><p>支持了 tree-shaking （剪枝）：像修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。</p><p>需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半（13kb）。哪怕把所有的功能都引入进来也只有23kb，依然比 Vue2.x 更小。像 keep-alive 、 transition 甚至 v-for 等功能都可以按需引入。</p><h4 id="模板性能提升"><a class="header-anchor" href="#模板性能提升">¶</a>模板性能提升</h4><p>在之前的VDOM中，如果msg值发生改变，整个模版中的所有元素都需要重新渲染。但在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。只能带patchFlag 的 Node 才被认为是动态的元素，会被追踪属性的修改。并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。<br>每一个Block中的节点，就算很深，也是直接跟Block一层绑定的，可以直接跳转到动态节点而不需要逐个逐层遍历。<br>既有VDOM的灵活性，又有性能保证。<br>vue3 使用 hoistStatic 静态节点提升<br>当使用hoistStatic时，所有 静态的节点都被提升到render方法之外。这意味着，他们只会在应用启动的时候被创建一次，而后随着每次的渲染被不停的复用。</p><h4 id="时间分片"><a class="header-anchor" href="#时间分片">¶</a>时间分片</h4><p>在动态节点和数据的量都很大时，那么在数据更新时，js线程就会用很长的时间来执行vdom的相关计算，如果超过了16ms，造成交互或动画等等卡顿现象。而时间分片就是把vdom的大量计算分成多个小任务，保证每个小任务在16ms内执行完，从而不会阻塞用户交互，避免卡顿现象。<br>然鹅，此功能还未包含在vue3的更新中。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/147022323">https://zhuanlan.zhihu.com/p/147022323</a><br><a href="https://www.jianshu.com/p/1d2846f2a855">https://www.jianshu.com/p/1d2846f2a855</a><br><a href="https://v3.vuejs.org/">https://v3.vuejs.org/</a><br><a href="https://segmentfault.com/a/1190000024580501">https://segmentfault.com/a/1190000024580501</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;总结一下最近一段时间学习 vue3 的收获&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;功能方面&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#功能方面&quot;&gt;¶&lt;/a&gt;功能方面&lt;/h2&gt;
&lt;h4 id=&quot;Compositi
      
    
    </summary>
    
    
      <category term="vue3" scheme="https://zzz1220.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>开启网页3D效果之旅</title>
    <link href="https://zzz1220.github.io/posts/3d46f50c/"/>
    <id>https://zzz1220.github.io/posts/3d46f50c/</id>
    <published>2019-07-27T13:30:31.000Z</published>
    <updated>2023-11-07T07:24:45.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上古时代，当<code>html</code>语言和<code>http</code>协议刚被发明出来时，这些专家们也许怎么也想不到，当初发明来共享文本的技术如今统治了几乎整个互联网行业。当第一个网页被打开时，上面只有简陋的一个表单，甚至做一个简单的过渡变色效果，都要借用<code>java Applet</code>，后来要借助<code>javascript</code>。短短十几年过去，现在有了<code>css3</code>，你只需定义简单的<code>transition</code>,就可以实现各种神奇的过渡效果。</p></blockquote><p>本文不是介绍<code>css3</code>动画以及用法的，因此需要读者预先了<code>transition</code>,<code>transform</code>等属性。</p><p>###　回顾下<code>CSS3</code>的基础属性</p><h4 id="1-transition"><a class="header-anchor" href="#1-transition">¶</a>1.<code>transition</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>是被用到最多的也是最简单的<code>CSS3</code>动画类型，如果你想实现鼠标划过更改背景色的功能，用<code>transition</code>是最简单的方式。</p><pre><code class="language-html">&lt;button&gt;会变色的按钮&lt;/button&gt;</code></pre><pre><code class="language-css">button {  transition: all 0.8s ease;  background-color: red;}button:hover {  background-color: #eeeeee;}</code></pre><p>下面是效果：</p><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master/img/1.gif" alt="gif"></p><p><strong>transition</strong> <a href="https://developer.mozilla.org/en/CSS" target="_blank" rel="noopener">CSS</a> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property" target="_blank" rel="noopener"><code>transition-property</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration" target="_blank" rel="noopener"><code>transition-duration</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function" target="_blank" rel="noopener"><code>transition-timing-function</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay" target="_blank" rel="noopener"><code>transition-delay</code></a> 的一个<a href="https://developer.mozilla.org/en-US/docs/CSS/Shorthand_properties" target="_blank" rel="noopener">简写属性</a>。分别是可变换属性，持续时间，变换的过度函数(就是变换的加速度曲线)，效果生效的延时。</p><p>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>的更多<code>API</code>，请查看<code>MDN</code>的文档。</p><h4 id="2-transform"><a class="header-anchor" href="#2-transform">¶</a>2.<code>transform</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="noopener">transform</a>是执行元素旋转，缩放，位移，倾斜的<code>css</code>属性，它是通过修改视觉上的坐标空间实现的。</p><p>⚠️ 只能转换盒子模型定位的元素。</p><ul><li>旋转<br><code>rotate(a)</code><br>a 是一种<angle>，表示旋转的角度，比如<code>30deg</code>。 正角度表示了顺时针的旋转，负角度表示逆时针的旋转。</angle></li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;rotated&quot;&gt;旋转45度&lt;/div&gt;&lt;div class=&quot;rotated2&quot;&gt;旋转90度&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;}.rotated {  transform: rotate(45deg);  background-color: pink;}.rotated2 {  transform: rotate(90deg);  background-color: blue;  color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/2.gif" alt="gif"></p><ul><li>缩放<br><code>scale(a,b,c)</code><br><em>单一数值</em><br>单一的数值即指定了一个缩放系数，同时作用于 X 轴和 Y 轴让该元素进行缩放，相当于指定了单个值的 scale()(2D 缩放)函数。<br><em>两个长度/百分比值</em><br>两个数值即分别指定了 2D 比例的 X 轴和 Y 轴的缩放系数，相当于指定了两个值的 scale()（2D 缩放）函数。<br><em>三个长度/百分比值</em><br>三个数值即分别指定了 3D 比例的 X 轴、Y 轴和 Z 轴的缩放系数. 相当于一个 scale3d()函数。<br>none<br>指定不进行缩放。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;scale&quot;&gt;大2倍&lt;/div&gt;&lt;div class=&quot;scale2&quot;&gt;水平1.5倍，垂直2倍&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;  text-align: center;  transform-origin: 0 0;}.scale {  transform: scale(2);  background-color: pink;}.scale2 {  transform: scale(1.5, 2);  background-color: blue;  color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/3.gif" alt="gif"></p><ul><li>位移<br><code>translate(x,y)</code><br>x,y 分别是 x,y 轴移动的距离。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;translate&quot;&gt;右，下移30px&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;  text-align: center;  transform-origin: 0 0;}.translate {  transform: translate(30px, 30px);  background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/4.gif" alt="gif"></p><ul><li>倾斜</li></ul><p><code>skew(x-angle,y-angle)</code><br>定义沿着 X 和 Y 轴的 2D 倾斜转换。</p><pre><code class="language-html">&lt;div&gt;Normal&lt;/div&gt;&lt;div class=&quot;skewed&quot;&gt;Skewed&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;}.skewed {  transform: skew(10deg); /* Equal to skewX(10deg) */  background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/5.gif" alt="gif"></p><h4 id="3-animation"><a class="header-anchor" href="#3-animation">¶</a>3.<code>animation</code></h4><p>我们可以把<code>transition</code>和<code>transform</code> 结合在一起使用，就实现动感十足的 html 页面。<br>但是，<code>transition</code>只能实现开始和结束的状态，并且只能“动一次”。</p><p>还有更加强大的<code>animation</code>属性，可以制作不间断，存在中间状态的动画。</p><p>💥 这里穿插介绍一个<code>animation</code>动画库，<a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">https://daneden.github.io/animate.css/</a></p><p><code>animate.css</code>里面实现了很多常见的淡入淡出，方向移动的动画，可以看下源码，然后自己实现动画的时候就有头绪了。</p><p>下面是一个简单的 fadeout 效果的源代码</p><pre><code class="language-css">@keyframes fadeOutDown {  from {    opacity: 1;  }  to {    opacity: 0;    transform: translate3d(0, 100%, 0);  }}</code></pre><p>点击<code>animate.css</code>官网可以查看更多的效果哦。<img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master/img/6.gif" alt="gif"></p><p>理论上，任何单独的<code>css</code>属性都可以拿来做动画，但是注意一点🙉从无到有，不要用<code>display:none</code>,应该用<code>opacity</code>属性。</p><p>然后是<code>animate</code>的属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> <strong>animation</strong> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener"><code>animation-name</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration" target="_blank" rel="noopener"><code>animation-duration</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function" target="_blank" rel="noopener"><code>animation-timing-function</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay" target="_blank" rel="noopener"><code>animation-delay</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count" target="_blank" rel="noopener"><code>animation-iteration-count</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction" target="_blank" rel="noopener"><code>animation-direction</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode" target="_blank" rel="noopener"><code>animation-fill-mode</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state" target="_blank" rel="noopener"><code>animation-play-state</code></a> 属性的一个简写属性形式。</p><p>这里不一一介绍了。</p><h1></h1><h3 id="进入主题-transform的3d效果"><a class="header-anchor" href="#进入主题-transform的3d效果">¶</a>进入主题–<code>transform</code>的<code>3D</code>效果</h3><p>☑️ 网页的<code>3D</code>坐标系：</p><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/1328957-20190425135458622-1593901679.jpg" alt></p><p>如上图，网格就是网页的坐标系。有了这张图，就可以很轻松的想到如何运用<code>css</code>的属性得到想要的效果。</p><h4 id="1-如何使用3d"><a class="header-anchor" href="#1-如何使用3d">¶</a>1.如何使用<code>3d</code></h4><p><code>transform</code>的<code>translate</code>,<code>scale</code>,<code>rotate</code>都有<code>3D</code>效果。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 转化。</td></tr><tr><td>translateX(<em>x</em>)</td><td>定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td>translateY(<em>y</em>)</td><td>定义 3D 转化，仅使用用于 Y 轴的值。</td></tr><tr><td>translateZ(<em>z</em>)</td><td>定义 3D 转化，仅使用用于 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 缩放转换。</td></tr><tr><td>scaleX(<em>x</em>)</td><td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td>scaleY(<em>y</em>)</td><td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td></tr><tr><td>scaleZ(<em>z</em>)</td><td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td>定义 3D 旋转。</td></tr><tr><td>rotateX(<em>angle</em>)</td><td>定义沿 X 轴的 3D 旋转。</td></tr><tr><td>rotateY(<em>angle</em>)</td><td>定义沿 Y 轴的 3D 旋转。</td></tr><tr><td>rotateZ(<em>angle</em>)</td><td>定义沿 Z 轴的 3D 旋转。</td></tr></tbody></table><p>也可以用</p><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr></tbody></table><p>下面是 3D 变换的例子</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/zzz1220/se45nykp/9//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>上面可以看出来，<code>div</code>脱离了平面，但是效果却仿佛还是平面的，因为我们缺少定义了一个关键的属性：</p><p>🏷<code>persspective</code>给元素加上<code>3D</code>透视(近大远小)的效果。</p><pre><code class="language-css">transform: perspective(600px); // 加在子元素上，给单个元素添加透视/**或者**/perspective: 600px; // 加在父元素上，所有的子元素共享一个3D空间</code></pre><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/zzz1220/oy0rwgh7/32//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>看上面的例子，我们可以看出，给单个元素添加，每个元素都有自己的透视空间。</p><p>🏷<code>perspective-orgin</code>默认的变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整。</p><p>就像<code>transform-origin</code>在 2D 变换里面设置变换中心点一样。也可以认为是元素的底部位置。</p><p>🏷<code>transform-style</code>这个参数用来共享父元素的 3D 空间。</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">flat</td><td style="text-align:left">表示所有子元素在 2D 平面呈现。</td></tr><tr><td style="text-align:left">preserve-3d</td><td style="text-align:left">表示所有子元素在 3D 空间中呈现。</td></tr></tbody></table><p>🏷<code>backface-visibility</code>可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。</p><h4 id="2-3d和硬件加速"><a class="header-anchor" href="#2-3d和硬件加速">¶</a>2.<code>3d</code>和硬件加速</h4><p>动画卡顿是在移动 web 开发时经常遇到的问题，解决这个问题一般会用到<strong>css3 硬件加速</strong>。</p><p>❔什么是硬件加速？</p><p>DOM 树和 CSS 结合后形成渲染树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到 GPU 形成渲染纹理。GPU 中 transform 是不会触发 repaint 的，这一点非常类似 3D 绘图功能，最终这些使用 transform 的图层都会由[独立的合成器进程进行处理]。<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p><p>因此，最简单的开启硬件加速的方法就是设置<code>translateZ(0)</code>。</p><p>但是，开启硬件加速后，会加快用电，并且不合适的使用硬件加速，会造成页面卡顿。</p><p>参考：<a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a> 看下<code>index</code>属性造成不该在复合层（composited layer）中的元素造成页面卡顿的例子。</p><h4 id="3-3d动画的一个实例"><a class="header-anchor" href="#3-3d动画的一个实例">¶</a>3. <code>3d</code>动画的一个实例</h4><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/zzz1220/tj1of0m5//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>利用<code>translate</code> 和 <code>rotate</code> 制作的一个骰子。</p><p>代码来源：</p><p><a href="https://www.cnblogs.com/zhangnan35/p/10709876.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangnan35/p/10709876.html</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/f8b1d6e598db" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b1d6e598db</a></p><p><a href="http://beiyuu.com/css3-animation" target="_blank" rel="noopener">http://beiyuu.com/css3-animation</a></p><p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上古时代，当&lt;code&gt;html&lt;/code&gt;语言和&lt;code&gt;http&lt;/code&gt;协议刚被发明出来时，这些专家们也许怎么也想不到，当初发明来共享文本的技术如今统治了几乎整个互联网行业。当第一个网页被打开时，上面只有简陋的一个表单，甚至做一个简单
      
    
    </summary>
    
    
      <category term="css" scheme="https://zzz1220.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>装饰器的简单实现（下）</title>
    <link href="https://zzz1220.github.io/posts/72b1723d/"/>
    <id>https://zzz1220.github.io/posts/72b1723d/</id>
    <published>2019-07-03T12:15:02.000Z</published>
    <updated>2023-11-08T07:30:23.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上文介绍了装饰模式，装饰器语法，今天继续说一下怎么用javascript实现自定义装饰器。</p></blockquote><h3 id="启用装饰器语法"><a class="header-anchor" href="#启用装饰器语法">¶</a>启用装饰器语法</h3><p>目前<code>decorator</code>语法只是题案，想要使用装饰器，需要安装<code>babel</code>和<code>webpack</code>并结合<code>babel/plugin-proposal-decorators</code> 插件。</p><p>关于如何配置请参考<code>babel</code>插件的配置文档。</p><p>或者你也可以直接到 <a href="https://babeljs.io/repl/" target="_blank" rel="noopener">https://babeljs.io/repl/</a> 这个地址编写代码，它提供了一个在线的<code>repl</code>环境，可以直接运行<code>es6</code>代码,记得勾选左侧的<code>Experimental</code>来启用装饰器语法。</p><p>🔑 <code>es2015</code>,<code>es2016</code>,<code>es2017</code>和<code>es6</code>之间的关系：</p><blockquote><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p></blockquote><h3 id="类装饰器-方法装饰器和属性装饰器"><a class="header-anchor" href="#类装饰器-方法装饰器和属性装饰器">¶</a>类装饰器，方法装饰器和属性装饰器</h3><h5 id="类装饰器"><a class="header-anchor" href="#类装饰器">¶</a>类装饰器</h5><p>类装饰器就是用来修改类的行为，它标注在类定义的上方。</p><pre><code class="language-javascript">@testableclass MyTestableClass {  // ...}function testable(target) { // target 就是被装饰的类  target.isTestable = true;}MyTestableClass.isTestable // true</code></pre><p>这是一个简单的类装饰器，它给被装饰的类添加了一个<code>isTestable</code>的静态属性。</p><p>上面是个简单的例子，下面来个稍微复杂的。<br>想一下，如果我们想给装饰器传参数，要怎么做？熟悉高阶函数的同学一定会立刻想到，函数可以返回函数，只要在装饰器函数外面再加一层函数就可以了。</p><pre><code class="language-javascript">function testable(isTrue) {return function(target) {target.isTestable = isTrue}}@testable(false)class MyTestableClass {}MyTestableClass.isTestable  // false</code></pre><p>上面是给类添加静态属性，如果想给实例添加属性，需要把属性添加在<code>prototype</code>上</p><pre><code class="language-javascript">function testable(isTrue) {return function(target) {target.prototype.isTestable = isTrue}}</code></pre><p>🔑 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><p>接下来来个稍微复杂一点的例子，用装饰器实现<code>mixin</code>,<br>🔑 mixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能。</p><pre><code class="language-javascript">function mixin(foo) {return function(target){Object.assign(target.prototype,foo) // Onject.assign 是es6里面的Object的新函数，用来把第二个参数的属性合并到第一个参数上 因为这里传入的是类（也就是构造函数），想要在实例上添加属性，需要合并到原型对象上。}}const Foo = {sayHi(){console.log('hi')}}@mixin(Foo)class Target{}new Target().sayHi()// Hi</code></pre><p>有了装饰器，之前那些烦人的样板函数就可以用装饰器代替了，比如我们用<code>redux</code>和<code>react</code>时，需要把<code>ui</code>组件和逻辑组件合并，经常需要写下面的代码：</p><pre><code class="language-javascript">class MyReactComponent extends React.Component {}export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);</code></pre><p>有了装饰器，就可以改写上面的代码。</p><pre><code class="language-javascript">@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component {}</code></pre><h5 id="方法和属性的装饰"><a class="header-anchor" href="#方法和属性的装饰">¶</a>方法和属性的装饰</h5><p>上面的装饰器定义函数我们只用到了一个参数，实际上，在装饰类的属性/方法时他有三个函数。</p><pre><code class="language-javascript">/*** target 被装饰的类的原型对象,需要注意，装饰class和class的属性，第一个参数是不一样的，装饰class时，是构造函数，也就是类本身* key 要修饰的属性名* descriptor 该属性的描述对象*/function decorator(target,key,descriptor){}</code></pre><p>🔑 关于描述对象，不熟悉的可以去看<code>js高级程序设计</code>关于 <code>defineProperty</code> 和 <code>defineProperties</code>的介绍，这两个方法就是用来定义和修改对象的内部属性。<br>举一个常见的例子，在每次函数执行前后，把函数的参数和结果打印出来</p><pre><code class="language-javascript">function log(target,key,descriptor) {var old = descriptor.valuedescriptor.value = function(...args) {console.log(`call ${key} with,`,...args)const result = old.call(this,...args)console.log(`result is ${result}`)return result}return descriptor}class Util {@logadd(a,b) {return a + b}}const util = new Util()util.add(1,2)// 这时，控制台会打印出日志// call add with, 1 2// result is 3</code></pre><p>来一个可缓存的装饰器</p><pre><code class="language-javascript">function cacheable(target,key,descriptor) {const old = descriptor.valueif( typeof old !== 'function' ) {throw new Error(&quot;must be a function&quot;)}const cache = {}descriptor.value = function(...args) {const key = JSON.stringify(args)if(cache[key]) {return cache[key]} else {cache[key] = old.call(this,...args)return cache[key]}}return descriptor}class Util {@cacheableadd(a,b) {console.log(&quot;add&quot;,a,b)return a + b}}const util = new Util()util.add(1,2)util.add(1,2)util.add(1,2)// 只有第一次运行会打印出 add 1 2</code></pre><p>同样的，我们也可以实现属性上的装饰器，比如实现一个类似<code>java</code>包装类</p><pre><code class="language-javascript">class Integer{constructor(num){this.value = num}display() {console.log(`this is a boxing value , the value is ${this.value}`)}}function boxing(target,key,descriptor) {    let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this);    v= new Integer(v)return {        enumerable: true,            configurable: true,            get: function() {                return v;            },            set: function(c) {                v = new Integer(c);            }    }} class Number {@boxinga=2}let number = new Number()number.a.display()// this is a boxing value , the value is 2number.a = 4number.a.display()// this is a boxing value , the value is 4</code></pre><p>这样，我们就实现了一个简单的包装<code>Integer</code>。</p><p>如果我们每次赋值的时候，都希望检查一下数据类型，可以这样做</p><pre><code class="language-javascript">function check(type) {return function(target,key,descriptor) {let v = descriptor.initializer &amp;&amp; descriptor.initializer.call(this)return {        enumerable: true,            configurable: true,            get: function() {                return v;            },            set: function(c) {if(typeof c !== type) {throw new Error(&quot;error type&quot;)}v = c}        }    }}</code></pre><h3 id="第三方库"><a class="header-anchor" href="#第三方库">¶</a>第三方库</h3><p><code>core-decorators.js</code>是一个第三方模块，提供了一些常见的装饰器<br>比如：</p><pre><code class="language-javascript">// @autobindimport { autobind } from 'core-decorators';class Person {  @autobind  getPerson() {    return this;  }}let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true// @readonlyimport { readonly } from 'core-decorators';class Meal {  @readonly  entree = 'steak';}var dinner = new Meal();dinner.entree = 'salmon';// Cannot assign to read only property 'entree' of [object Object]</code></pre><p>还有更多不再阐述。</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>上文只是简单对装饰器模式做了基本原理的解释和简单demo，具体在实战中如何应用，还需要很多其他的经验，比如多个装饰器嵌套如何使用，如何利用<code>proxy</code>实现装饰器，在上文中都没提及，在接下来的博文里，会完整的实现一个具有实际意义的装饰器例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上文介绍了装饰模式，装饰器语法，今天继续说一下怎么用javascript实现自定义装饰器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启用装饰器语法&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#启用装饰器语法&quot;&gt;¶&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>装饰器的简单实现（上）</title>
    <link href="https://zzz1220.github.io/posts/72b172aa/"/>
    <id>https://zzz1220.github.io/posts/72b172aa/</id>
    <published>2019-07-01T13:29:17.000Z</published>
    <updated>2023-11-08T07:30:23.184Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>es7</code>为<code>javascript</code>添加了激动人心的新特性----装饰器，不过<code>Typrscript</code>早就支持了装饰器了，装饰器也不是<code>ts</code>特有的语法，实际上<code>python</code>也有装饰器，在<code>oop</code>语言里面，一直都有装饰器模式，也称为<code>decorator</code>，不过都是从语言层面，通过继承和组合实现，现在，我们可以通过语法层面直接实现装饰器了。</p></blockquote><h3 id="什么是装饰器模式"><a class="header-anchor" href="#什么是装饰器模式">¶</a>什么是装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p><code>java</code>里面的装饰器模式:</p><p>参考这个地址：<a href="https://github.com/iluwatar/java-design-patterns/tree/master/decorator" target="_blank" rel="noopener"><strong>decorator</strong></a></p><p>🔼上面的地址是<code>github</code>上一个很有名的各种设计模式的<code>java</code>实现。</p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p></blockquote><p>也就是说：动态的将附加职责添加到对象上。装饰器模式为子类化提供了灵活的代替和扩展的功能。</p><p>举个例子：</p><p>我们小时候都打过<code>cs</code>，每个警察或者劫匪都可以拿一把武器，或者是<code>AK47</code>，或者是<code>m16</code>，为了更换武器，我们没必要去创造新的角色实例，可以用装饰器动态的用武器装饰他。</p><pre><code class="language-java">// 创建一个角色接口public interface Person {  void attack();  int getAttackPower();}public class Police implements Person {    void attack(){        Systom.out.print(&quot;I'm attacking you&quot;);    }    int getAttackPower(){        return 5; // 战斗力只有5的渣渣    }}public class AkPolice implements Person {    // 提供构造函数来对目标进行包装    public AkPolice(Police decorted) {        this.decorted = decorted;     }    void attack(){        this.decorted.attack()        Systom.out.print(&quot;I'm attacking with a Ak!!&quot;);//awesome!    }    int getAttackPower(){        return this.decorted.getAttackPower()+100;    }}</code></pre><p>🔼就像上面的简单例子，一个包装类把基本类<code>warped</code>起来，形成了一个新的类，新的类不仅添加了新的动作，还保留了基本类的动作。</p><p>优点：</p><p>👍 装饰模式与继承关系的目的都是要拓展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者“除掉”一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>👍 通过不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出更多不同行为的组合。</p><p>缺点：</p><p>👎种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p><p>装饰器语法最常见的应用就是我们熟悉的<code>java</code>里面的<code>AOP</code>(面向切面)编程，在不影响原有功能的情况下，增加新的处理逻辑，比如添加各种<code>filter</code>,这些<code>filter</code>就像洋葱一样层层包裹，最终执行原有的逻辑，但是在之前和之后，都可以随意添加新的行为，因此，特别适合安全检查，缓存，调试，日志记录等等行为。</p><h3 id="装饰器语法"><a class="header-anchor" href="#装饰器语法">¶</a>装饰器语法</h3><p>第一次看到装饰器语法是在使用<code>python</code>的时候，现在<code>es7</code>也实现了装饰器语法。</p><p>首次看到装饰器语法，用过<code>java</code>注解的也许会混到一起，其实这两个东西除了长得像外，原理完全不一样。</p><blockquote><p>Python decorators were inspired in part by Java annotations, and have a similar syntax</p><p>​                                                                                                                      --wikipedia</p></blockquote><p>根据<code>wikipedia</code>的说法，装饰器语法的灵感来源于<code>java</code>的注解，所以他们有类似的语法。</p><p>注解是利用反射，它本身不改变被注解对象的行为和性质，只有理解这些注解的处理器才会改变行为，在运行的时候起作用。</p><p>装饰器实际上是语法糖，利于了<code>python</code>,<code>javascript</code>函数可以赋值，传参的特性，函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，对嵌套函数做了简化。</p><p>😋引申：如果想了解更多关于<code>javascript</code>函数式特性的知识，可以看下面⬇️</p><p>[<a href="https://www.bookstack.cn/books/mostly-adequate-guide-chinese" target="_blank" rel="noopener">JS 函数式编程指南中文版</a> ](<a href="https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md</a>)</p><p>相信看完，你会对<code>javascript</code>有新的认识。</p><p>下面重头戏来了，到底在<code>javascript</code>里，怎么实现自己的装饰器呢？</p><p>关键的<code>api</code>是<code>Object.defineProperty</code>。</p><pre><code class="language-javascript">Object.defineProperty(obj, prop, descriptor)</code></pre><p>参数：</p><p><strong>obj</strong> 要在其上定义属性的对象</p><p><strong>prop</strong> 要定义或修改的属性的名称。</p><p><strong>descriptor</strong> 将被定义或修改的属性描述符。</p><p>装饰器可以用到<code>类</code>，属性和类的<code>方法</code>上，不能用于<code>function</code>❔<a href="http://es6.ruanyifeng.com/#docs/decorator#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F" target="_blank" rel="noopener">为什么修饰器不能用于函数？</a></p><p>👍想详细了解装饰器语法，可以去看阮一峰老师的<code>es6</code>教程</p><p><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">修饰器</a></p><p>下篇博文，我会用实例代码实现不同的装饰器（等我看完上面的教程先😄)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;es7&lt;/code&gt;为&lt;code&gt;javascript&lt;/code&gt;添加了激动人心的新特性----装饰器，不过&lt;code&gt;Typrscript&lt;/code&gt;早就支持了装饰器了，装饰器也不是&lt;code&gt;ts&lt;/code&gt;特有的语法，实际上
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Performance--一个用来获取页面性能的接口</title>
    <link href="https://zzz1220.github.io/posts/94e1353c/"/>
    <id>https://zzz1220.github.io/posts/94e1353c/</id>
    <published>2019-06-25T06:29:02.000Z</published>
    <updated>2023-11-07T06:53:35.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近被问到一个问题，如何判断页面加载时间，我第一时间想到的是打开<code>devtool</code>看下<code>Network</code>下面</p><p><code>DOMContentLoaded</code>和<code>load</code>分别用了多久，如果自己写的话，要用到<code>window.onload</code>函数，但是实际上，web已经给出了<code>api</code>，获取页面性能，并且大部分现代浏览器也支持这个<code>api</code>.</p></blockquote><h3 id="Performance简介"><a class="header-anchor" href="#Performance简介">¶</a><strong>Performance</strong>简介</h3><p>根据<code>mdn</code>里面的说法:</p><blockquote><p><strong>Performance</strong> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API">Resource Timing API</a>。</p></blockquote><p>并且，这些数据是只读的。</p><p><code>preformance</code>对象有三个标准属性，和一个<code>chrome</code>添加的非标准库–<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory"><code>performance.memory</code></a>，用来获取到基本内存的使用情况，一般来说不要用这个非标准的<code>api</code>。</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/navigation"><code>Performance.navigation</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceNavigation"><code>PerformanceNavigation</code></a> 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等。Not available in workers.</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timing"><code>Performance.timing</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming"><code>PerformanceTiming</code></a> 对象包含延迟相关的性能信息。Not available in workers.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory"><code>performance.memory</code></a></p><p>其是 Chrome 添加的一个非标准扩展，这个属性提供了一个可以获取到基本内存使用情况的对象。<strong>不应该</strong>使用这个非标准的 API。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timeOrigin"><code>Performance.timeOrigin</code></a> [只读]</p><p>返回性能测量开始时的时间的高精度时间戳。</p><p>关于更精确的资料请查看<code>mdn</code>官方文档。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance">Performance</a></p><h3 id="如何根据Performance-timing获取加载时间"><a class="header-anchor" href="#如何根据Performance-timing获取加载时间">¶</a>如何根据<code>Performance.timing</code>获取加载时间</h3><p>在此之前，读者需要明白一点浏览器工作的基本流程和原理，比如经常在面试时被问到的“从url输入到页面加载经过了什么流程？”</p><p>这里有几篇非常详细的文章（最起码是我遇到的最详细的，如果你看到过更详细的，或者还有其他补充，请在下方留言，万分感谢😙 ），介绍了这个流程。</p><p><a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p>也就是说，你最起码要知道<code>dns</code>解析，<code>http</code>请求，页面渲染等认识。</p><p><code>timing</code>就是从输入<code>url</code>到页面展示的全过程的时间统计，单位是毫秒，只读。</p><p>➕ 属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart"><code>PerformanceTiming.navigationStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和PerformanceTiming.fetchStart相同。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventStart"><code>PerformanceTiming.unloadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventEnd"><code>PerformanceTiming.unloadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectStart"><code>PerformanceTiming.redirectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectEnd"><code>PerformanceTiming.redirectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/fetchStart"><code>PerformanceTiming.fetchStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupStart"><code>PerformanceTiming.domainLookupStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupEnd"><code>PerformanceTiming.domainLookupEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectStart"><code>PerformanceTiming.connectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectEnd"><code>PerformanceTiming.connectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/secureConnectionStart"><code>PerformanceTiming.secureConnectionStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/requestStart"><code>PerformanceTiming.requestStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseStart"><code>PerformanceTiming.responseStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseEnd"><code>PerformanceTiming.responseEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domLoading"><code>PerformanceTiming.domLoading</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构开始解析时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState"><code>Document.readyState</code></a>属性变为“loading”、相应的 <code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domInteractive"><code>PerformanceTiming.domInteractive</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构结束解析、开始加载内嵌资源时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState"><code>Document.readyState</code></a>属性变为“interactive”、相应的<code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventStart"><code>PerformanceTiming.domContentLoadedEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当解析器发送<code>DOMContentLoaded</code> 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventEnd"><code>PerformanceTiming.domContentLoadedEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domComplete"><code>PerformanceTiming.domComplete</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前文档解析完成，即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState"><code>Document.readyState</code></a> 变为 <code>'complete'且相对应的``readystatechange</code> 被触发时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventStart"><code>PerformanceTiming.loadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回该文档下，<code>load</code>事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventEnd"><code>PerformanceTiming.loadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当<code>load</code>事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</p><p>🔼 以上属性来自<code>mdn</code>文档。</p><p>根据上面的定义，可以得出下面的常用的时间计算公式：</p><p><strong>常用计算：</strong><br><code>DNS</code>查询耗时 ：<code>domainLookupEnd</code> - <code>domainLookupStart</code><br><code>TCP</code>链接耗时 ：<code>connectEnd</code> -<code> connectStart</code><br><code>request</code>请求耗时 ：<code>responseEnd</code> - <code>responseStart</code><br>解析<code>dom</code>树耗时 ： <code>domComplete</code> - <code>domInteractive</code><br>白屏时间 ：<code>responseStart</code> -<code> navigationStart</code><br><code>domready</code>时间(用户可操作时间节点) ：<code>domContentLoadedEventEnd</code> -<code> navigationStart</code><br><code>onload</code>时间(总下载时间) ：<code>loadEventEnd</code> - <code>navigationStart</code></p><h4 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h4><p>[<a href="https://www.cnblogs.com/bldxh/p/6857324.html">Performance — 前端性能监控利器</a>](<a href="https://www.cnblogs.com/bldxh/p/6857324.html">https://www.cnblogs.com/bldxh/p/6857324.html</a>)</p><p><a href="https://w3c.github.io/navigation-timing/#introduction">w3c文档(<a href="https://w3c.github.io/navigation-timing/#introduction">https://w3c.github.io/navigation-timing/#introduction</a>)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">mdn文档(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming</a>)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近被问到一个问题，如何判断页面加载时间，我第一时间想到的是打开&lt;code&gt;devtool&lt;/code&gt;看下&lt;code&gt;Network&lt;/code&gt;下面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOMContentLoaded&lt;/code&gt;和&lt;code&gt;load
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>加法模拟器</title>
    <link href="https://zzz1220.github.io/posts/909f226/"/>
    <id>https://zzz1220.github.io/posts/909f226/</id>
    <published>2019-06-10T15:43:00.000Z</published>
    <updated>2023-11-08T07:30:23.184Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不用 “+” 怎么实现加法呢？相信大家看到第一时间就会想到用位运算，特别是计算机基础好的同学，立马想到计算机本质不就是2进制做位运算实现计算的吗？</p></blockquote><h3 id="先复习下位运算"><a class="header-anchor" href="#先复习下位运算">¶</a>先复习下位运算</h3><p>与运算<code>&amp;</code><br><code>2&amp;3</code><br>2的2进制是<code>10</code><br>3的2进制是<code>11</code><br>所以就是<code>10</code>和<code>11</code>做与运算,只有双方都是<code>true</code>的时候，结果才为<code>true</code>。</p><p>注意：如果是负数，需要计算补码来做位运算，正数的补码和本身相等。比如<code>-1</code></p><p>源码 1000 0001</p><p>反码 1111 1110</p><p>补码 1111 1111</p><table><thead><tr><th>与运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>false</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></tbody></table><table><thead><tr><th>或运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr></tbody></table><table><thead><tr><th>异或运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr></tbody></table><h3 id="异或和与运算"><a class="header-anchor" href="#异或和与运算">¶</a>异或和与运算</h3><p>异或</p><pre><code class="language-python">a = 10   # 1010b = 5    # 0101a^b = 15 # 1111c = 10    #1010d = 6     #0110c^b = 12  #1100</code></pre><p>与</p><pre><code class="language-python">a = 10  # 1010b = 5   # 0101a&amp;b = 0 # 0000c = 10   #1010d = 6    #0110c&amp;b = 2  #0010</code></pre><p>看出点眉目没有？<br>异或，得到的是两个数没进位的和；而与。得到的是需要进位的位置（这里的位置并不是一一对应，需要向左移动一位，）</p><p>算法</p><pre><code class="language-python">def add(a,b):    res = 0    while b != 0:        res = a^b        b = (a&amp;b)&lt;&lt;1        a = res        print(bin(a)[2:],bin(b)[2:])    return a  # 计算 10 加 6    add(10,6)#output 1100     100 1000    1000    0   1000010000       0# 结果16</code></pre><p>原理<br>a，b先用异或获取不进位的结果，在用与运算获取进位，这个称为进位补偿，然后把这两个结果相加就是a+b了，<br>但是不然用加法啊，怎么办呢？ 可以把前面的流程再走一次，直到进位补偿为0，这时候，上个异或结果就是最终相加的结果了。</p><p>根据上面的原理<br>1.a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)<br>2.无进位加法使用异或运算计算得出<br>3.进位结果使用与运算和移位运算计算得出<br>4.循环此过程，直到进位为 0</p><p>用一个公式就是</p><pre><code class="language-python">a + b = a^b + (a&amp;b)&lt;&lt;1</code></pre><p>不过其实还有更简单的方法,毕竟<br><strong>人生苦短，我选python</strong></p><pre><code class="language-python">def add(self, a, b):    return sum([a, b])</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;不用 “+” 怎么实现加法呢？相信大家看到第一时间就会想到用位运算，特别是计算机基础好的同学，立马想到计算机本质不就是2进制做位运算实现计算的吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;先复习下位运算&quot;&gt;&lt;a class=&quot;heade
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout和setInterval的区别</title>
    <link href="https://zzz1220.github.io/posts/64e435bc/"/>
    <id>https://zzz1220.github.io/posts/64e435bc/</id>
    <published>2019-06-05T10:55:13.000Z</published>
    <updated>2023-11-08T07:30:23.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们再前端开发中需要实现定时任务或者<code>js</code>动画，都要用到<code>setTimeout</code>和<code>setInterval</code>z这两个函数，但是对于他们的原理，如果不清楚，往往会造成一些意想不到的问题。</p></blockquote><h3 id="settimeout"><a class="header-anchor" href="#settimeout">¶</a><code>setTimeout</code></h3><p><code>setTimeout</code>方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。</p><p>语法</p><pre><code class="language-javascript">var id = setTimeout(function[,delay,param1...])var id = setTimeout(function[,delay])var id = setTimeout(code[,delay])</code></pre><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p><code>function</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function" target="_blank" rel="noopener"><code>function</code></a> 是你想要在到期时间(<code>delay</code>毫秒)之后执行的<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">函数</a>。</p><p><code>code</code></p><p>这是一个可选语法，你可以使用字符串而不是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function" target="_blank" rel="noopener"><code>function</code></a> ，在<code>delay</code>毫秒之后编译和执行字符串 (使用该语法是<strong>不推荐的,</strong> 原因和使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener"><code>eval()</code></a>一样，有安全风险)。</p><p><code>delay</code>可选</p><p>延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0，意味着“马上”执行，或者尽快执行。不管是哪种情况，实际的延迟时间可能会比期待的(delay毫秒数) 值长，原因请查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#Reasons_for_delays_longer_than_specified" target="_blank" rel="noopener">Reasons for delays longer than specified</a>。</p><p><code>param1, ..., paramN</code> 可选</p><p>附加参数，一旦定时器到期，它们会作为参数传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function" target="_blank" rel="noopener"><code>function</code></a></p><h4 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h4><p>返回值<code>timeoutID</code>是一个正整数，表示定时器的编号。这个值可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout" target="_blank" rel="noopener"><code>clearTimeout()</code></a>来取消该定时器。</p><h4 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h4><p>举个例子，三秒后跳转新页面</p><pre><code class="language-javascript">setTimeout(function() {    location.href = &quot;url&quot;},3000)</code></pre><p>在函数执行前取消</p><pre><code class="language-javascript">var key;function myFunction() {    key = setTimeout(function(){ console.log(&quot;fn&quot;) }, 3000);}function myStopFunction() {    clearTimeout(key);}</code></pre><p>如果你只是掌握了上面的用法，不了解它的原理，就会犯一些错误</p><p>比如一个常见的面试题</p><pre><code class="language-javas">for (var i = 1;i &lt;= 5;i ++) {  setTimeout(function timer() {      console.log(i)  },i * 1000)}</code></pre><p>问打印出来的是什么？</p><p>如果对闭包和作用域不了解的同学会以为是每隔一秒就输出1,2,3,4,5。但实际上是每隔一秒输出了6。</p><p>原因就是作用域，在<code>javascript</code>里面没有块作用域，因此，当<code>setTimeout</code>里面的函数执行的时候，所有的i都是<code>for</code>循环里面的<code>i</code>，此时，<code>i</code>是6。</p><p>另外，说到<code>setTimeout</code>就一定要说一下事件循环，这个概念比较复杂，下面简单说一下，</p><p><code>setTimeout</code>运行后，会把第一个参数的函数在第二个参数设置的时间之后，将其放入异步队列里面，然后等到主线程函数栈为空，在执行这个函数。</p><p>这里有个需要注意的地方，</p><blockquote><p>HTML5 标准规定了<code>setTimeout()</code>的第二个参数的最小值，即最短间隔，不得低于4毫秒。如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。</p></blockquote><p>这意味着，即使你把第二个参数设置为0，也要最少等个4ms才能进入异步队列。另外，就算进入异步队列,也要等队列里面其他未执行的函数执行完，因此，可不要以为只要设置一个时间，就一定可以准时执行这个函数。</p><p>那么，怎么让上面的代码打印出0,1,2,3,4,5呢？</p><p>可以用下面的方法。</p><p>1.<code>es6</code>的<code>let</code>关键词</p><p><code>let</code>是<code>es6</code>的块作用域的声明关键词。</p><pre><code class="language-javascript">for(let i = 0;i&lt;5;i++) {  setTimeout(function timer(){    console.log(i);  }, i * 1000);}</code></pre><p>2.利用闭包</p><pre><code class="language-javascript">for(var i = 0;i&lt;5;i ++) {  (function(i){    setTimeout(function timer() {      console.log(i)    }, i * 1000);  })(i);}</code></pre><p>3.利用第三个参数</p><pre><code class="language-javascript">for (var i=1; i&lt;=5; i++) {  setTimeout( function timer(i) {    console.log(i);       }, i*1000,i );}</code></pre><p>tips:</p><p><code>setTimeout</code>第一个参数函数里面的<code>this</code>是<code>window</code>。</p><p>###　setInterval</p><p><strong>setInterval()</strong> 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。</p><p>语法</p><pre><code class="language-javascript">let intervalID = window.setInterval(func, delay[, param1, param2, ...]);let intervalID = window.setInterval(code, delay);</code></pre><p>参数</p><ul><li><code>intervalID</code> 是此重复操作的唯一辨识符，可以作为参数传给<code>clearInterval``()</code>。</li><li><code>func</code> 是你想要重复调用的函数。</li><li><code>code</code> 是另一种语法的应用，是指你想要重复执行的一段字符串构成的代码(使用该语法是<strong>不推荐</strong>的，不推荐的原因和<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval#Don't_use_eval!" target="_blank" rel="noopener">eval()</a>一样)。</li><li><code>delay</code> 是每次延迟的毫秒数 (一秒等于1000毫秒)，函数的每次调用会在该延迟之后发生。和<a href="https://developer.mozilla.org/en-US/docs/DOM/window.setTimeout#Minimum_delay_and_timeout_nesting" target="_blank" rel="noopener">setTimeout</a>一样，实际的延迟时间可能会稍长一点。</li></ul><p>返回值</p><p>返回一个 intervalID。可以用clearInterval函数来取消定时任务。</p><p><strong>这里需要注意，于setTimeout返回的id公用一个id池</strong></p><p>通常，这个函数用来执行周期执行的函数，比如动画之类的效果。</p><p>mdn里面有个打字机效果的例子。</p><p><a href="https://mdn.mozillademos.org/files/3997/typewriter.html" target="_blank" rel="noopener">打字机效果</a></p><p>和<code>setTimeout</code>一样，也是加入到异步队列里，等待合适的时机运行。</p><blockquote><p>当使用<code>setInterval</code>时,仅当(在队列中)没有该定时器的任何其他代码实例时,才将定时器代码添加到队列中,引用JavaScript高级程序设计第三版书中语句</p></blockquote><p>(即：当前一个定时器代码执行时,紧跟后面的第一个定时器代码将添加到队列中,等待执行,再后面的定时器代码不会添加到队列中)</p><p>所以，如果你的函数（第一个参数）执行时间比较长，但是你的执行间隔时间设置的比较短，可不要以为可以精准的在预料的时间点会执行设置的函数。</p><p>此外，第二个参数也有一个最短的默认参数，在<code>chrome</code>里面是7ms。</p><p>当定时器代码执行时间超过指定间隔,那么某些定时器代码就会被跳过(即后面的定时器代码不会被添加到队列中),前一个定时器代码执行完毕后,队列中的定时器代码立刻执行,各定时器之间的代码执行没有间隔。这时，需要使用链式<code>setTimeout</code>。</p><pre><code class="language-javas">setTimeout(function(){    //要执行的代码     setTimeout(arguments.callee,2000);                   },2000);</code></pre><p>上面的代码就是用<code>setTimeout</code>来模拟<code>setInterval</code>,如果面试官问你怎么用<code>setTimeout</code>来解决定时器问题，可以用上面的代码来回答哦。</p><p>如果要求在每隔一个固定的时间间隔后就精确地执行某动作，那么最好使用<code>setInterval</code>，</p><p>比如函数执行的时间比较短的，用来实现动画效果。</p><p>如果每次函数的调用需要繁重的计算以及很长的处理时间，而且不希望他们之间互相干扰，那么最好使用<code>setTimeout</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们再前端开发中需要实现定时任务或者&lt;code&gt;js&lt;/code&gt;动画，都要用到&lt;code&gt;setTimeout&lt;/code&gt;和&lt;code&gt;setInterval&lt;/code&gt;z这两个函数，但是对于他们的原理，如果不清楚，往往会造成一些意想不到的问
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://zzz1220.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>快乐数</title>
    <link href="https://zzz1220.github.io/posts/9ba82001/"/>
    <id>https://zzz1220.github.io/posts/9ba82001/</id>
    <published>2019-06-03T12:34:42.000Z</published>
    <updated>2023-11-07T06:53:35.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>快乐就完事了。</p></blockquote><h3 id="快乐数是什么"><a class="header-anchor" href="#快乐数是什么">¶</a>快乐数是什么</h3><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">19</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: </span><br><span class="line"><span class="number">1</span>^<span class="number">2</span> + <span class="number">9</span>^<span class="number">2</span> = <span class="number">82</span></span><br><span class="line"><span class="number">8</span>^<span class="number">2</span> + <span class="number">2</span>^<span class="number">2</span> = <span class="number">68</span></span><br><span class="line"><span class="number">6</span>^<span class="number">2</span> + <span class="number">8</span>^<span class="number">2</span> = <span class="number">100</span></span><br><span class="line"><span class="number">1</span>^<span class="number">2</span> + <span class="number">0</span>^<span class="number">2</span> + <span class="number">0</span>^<span class="number">2</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="编写一个算法来判断一个数是不是“快乐数”。"><a class="header-anchor" href="#编写一个算法来判断一个数是不是“快乐数”。">¶</a>编写一个算法来判断一个数是不是“快乐数”。</h3><p>思路，不断的求输入数字每个位置平方和，然后看是否等于1，等于1就是快乐数，问题是，什么时候判断false。<br>答案就是出现无线循环的时候，也就是出现重复的数字，必定会进行下一次循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        already = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            nums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                temp = n % <span class="number">10</span></span><br><span class="line">                nums = nums + temp * temp</span><br><span class="line">                n = n // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> nums <span class="keyword">in</span> already:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                already.add(nums)</span><br><span class="line">                n = nums</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;快乐就完事了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;快乐数是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#快乐数是什么&quot;&gt;¶&lt;/a&gt;快乐数是什么&lt;/h3&gt;
&lt;p&gt;一个“快乐数”定义为：对于一个正整数，每一次
      
    
    </summary>
    
    
      <category term="python" scheme="https://zzz1220.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的循环遍历方法</title>
    <link href="https://zzz1220.github.io/posts/8925371c/"/>
    <id>https://zzz1220.github.io/posts/8925371c/</id>
    <published>2019-06-01T07:08:21.000Z</published>
    <updated>2023-11-07T06:53:35.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近稍微刷了一下<code>leetcode</code>，想巩固一下编程功底，但是发现工作后的很少用到在学校时用的数据结构，好多都忘了，在这里做下记录。</p></blockquote><h3 id="1-二叉树的前序，中序，后序遍历"><a class="header-anchor" href="#1-二叉树的前序，中序，后序遍历">¶</a>1.二叉树的前序，中序，后序遍历</h3><p>前序遍历方向是 中 左 右</p><p>中序遍历方向是 左 中 右</p><p>后序遍历方向是 右 左 中</p><p>根据上面的定义，看的出来对于左右节点，顺序是不变的，只是中间节点出现的位置改变。所以，这也是一个防止忘记的技巧。</p><h3 id="2-代码实现"><a class="header-anchor" href="#2-代码实现">¶</a>2.代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义节点对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备测试数据</span></span><br><span class="line">a = TreeNode(<span class="number">1</span>)</span><br><span class="line">a.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">a.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">a.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">a.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">a.right.left = TreeNode(<span class="number">6</span>)</span><br><span class="line">a.right.right = TreeNode(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归实现中序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inerderTraversalLoop</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环实现中序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr=curr.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = stack.pop()</span><br><span class="line">                result.append(curr.val)</span><br><span class="line">                curr = curr.right</span><br><span class="line">        <span class="keyword">return</span> result        </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归实现前序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.predorderTraversal(root.left) + self.predorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predorderTraversalLoop</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环实现前序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> curr:</span><br><span class="line">                result.append(curr.val)</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = stack.pop()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result         </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归实现后续遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversalLoop</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环实现后续遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> curr:</span><br><span class="line">               result.append(curr.val)</span><br><span class="line">               stack.append(curr.left)</span><br><span class="line">               curr = curr.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               curr = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]     </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.inorderTraversal(a))</span><br><span class="line">    <span class="built_in">print</span>(s.inerderTraversalLoop(a))</span><br><span class="line">    <span class="built_in">print</span>(s.predorderTraversal(a))</span><br><span class="line">    <span class="built_in">print</span>(s.predorderTraversalLoop(a))</span><br><span class="line">    <span class="built_in">print</span>(s.postorderTraversal(a))</span><br><span class="line">    <span class="built_in">print</span>(s.postorderTraversalLoop(a))</span><br><span class="line"><span class="comment"># [4, 2, 5, 1, 6, 3, 7]</span></span><br><span class="line"><span class="comment"># [4, 2, 5, 1, 6, 3, 7]</span></span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 3, 6, 7]</span></span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 3, 6, 7]</span></span><br><span class="line"><span class="comment"># [4, 5, 2, 6, 7, 3, 1]</span></span><br><span class="line"><span class="comment"># [4, 5, 2, 6, 7, 3, 1]   </span></span><br></pre></td></tr></table></figure><p>上面就是实现代码。</p><p>先说下递归实现，根据第一节的遍历顺序定义，这里很简单就可以写出递归程序，只是返回的时候，更改下中间节点的位置就好。</p><p>在说下循环实现，在<code>LeetCode</code>里面，循环都是<code>hard</code>和<code>middle</code>的题，可见，用循环实现起来并不容易。</p><p>主要是要在一个函数里面实现遍历到整个树形结构，如果你能想到用<strong>栈</strong>（<code>stack</code>）来存节点，那么你应该差不多对数据结构运用有一定经验了。</p><p>如下的二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">1</span></span><br><span class="line">   <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">5</span></span><br></pre></td></tr></table></figure><p>对于中序遍历</p><p>每次将当前结点<code>curr</code>的左子结点push到栈中，直到当前结点<code>curr</code>为None。这时，<code>pop</code>出栈顶的第一个元素，设其为当前结点，并输出该结点的<code>val</code>值，且开始遍历该结点的右子树。当<code>stack</code>和<code>curr</code>都为空的时候，结束循环。</p><p>对于前序遍历</p><p>输出当前结点<code>curr</code>的<code>val</code>，并将右子结点<code>push</code>到栈中，然后将左子结点设为当前结点。入栈和出栈条件（当前结点<code>curr</code>不为<code>None</code>时，每一次循环将当前结点<code>curr</code>入栈；当前结点<code>curr</code>为<code>None</code>时，则出栈一个结点）以及循环结束条件（整个循环在<code>stack</code>和<code>curr</code>皆为<code>None</code>的时候结束）与中序遍历一模一样。</p><p>对于后序遍历</p><p>后序遍历在<code>leetcode</code>上是<code>hard</code>难度的题，这里有个技巧，后序是左右中，我们按照中右左的方式遍历，然后反向输出就可以了。而且中右左不就是前序遍历左右互相换下吗？</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>二叉树的循环遍历，还是要借助于栈这个非常有用的数据结构，有时我们都明白，比如，栈啊，队列啊，这些结构有什么特性，但是，要真正灵活的使用这些数据结构，还需要多多练习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近稍微刷了一下&lt;code&gt;leetcode&lt;/code&gt;，想巩固一下编程功底，但是发现工作后的很少用到在学校时用的数据结构，好多都忘了，在这里做下记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-二叉树的前序，中序，后序遍历&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="python" scheme="https://zzz1220.github.io/tags/python/"/>
    
      <category term="二叉树" scheme="https://zzz1220.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
