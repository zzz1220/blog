<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>类型体操代码片段</title>
      <link href="/posts/5abfc5c1/"/>
      <url>/posts/5abfc5c1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&quot;TS类型体操&quot;通常是指在TypeScript中使用类型系统的一种技巧，以更好地利用TypeScript的类型检查功能。TypeScript是JavaScript的一个超集，它添加了静态类型定义，使得在开发大型应用程序时更容易进行类型检查和调试。TS类型体操是指利用TypeScript强大的类型系统，通过巧妙的类型定义和使用技巧，以及一些特殊的类型操作，来实现更高级、更复杂的类型检查和类型推断。</p></blockquote><p>最近为了更好的学习ts的类型系统，开始练习类型体操。地址：<br><a href="https://github.com/type-challenges/type-challenges" target="_blank" rel="noopener">https://github.com/type-challenges/type-challenges</a><br>记录一些常用的类型技巧</p><h1>类型体操包括哪些内容？</h1><p>TS类型体操可以包括以下内容：</p><p>类型推断和类型注解：TypeScript允许你在变量、函数参数、函数返回类型等地方进行类型注解，同时也有一定的类型推断机制，可以根据上下文自动推断类型。<br>联合类型和交叉类型：通过联合类型（Union Types）和交叉类型（Intersection Types），可以将多种类型组合在一起，实现更灵活的类型定义。<br>泛型：使用泛型可以在多个地方重用相同的类型，增加代码的灵活性和重用性。<br>条件类型：条件类型是TypeScript中的高级类型，允许根据其他类型来选择其中一种类型定义。<br>映射类型：映射类型允许你从一个现有的类型创建一个新的类型，其中每个属性都可以按照一定的规则转换。<br>类型守卫：使用类型守卫可以在运行时检查类型，帮助你在代码中处理不同的类型情况。<br>keyof 操作符：keyof 操作符用于获取对象类型的所有键，它常用于泛型约束和类型操作。<br>类型操作符：TypeScript提供了一些类型操作符，如keyof、typeof、in等，用于操作和获取类型信息。<br>索引类型：索引类型可以用于访问对象的属性，并保留其类型信息。</p><p>TS类型体操是利用TypeScript强大类型系统的一种技巧和思维方式，它可以帮助开发者更好地利用类型检查来提高代码的可靠性和健壮性。</p><h1>代码片段</h1><p>判断两个类型是否相等</p><pre><code class="language-ts">export type Equal&lt;X, Y&gt; = (&lt;T&gt;() =&gt; T extends X ? 1 : 2) extends &lt;T&gt;() =&gt; T extends Y ? 1 : 2  ? true  : false</code></pre><p>遍历一个数组的类型</p><pre><code class="language-ts">type TupleToObject&lt;T extends readonly any[]&gt; = {  // 遍历写法：[key in T[number]]  [key in T[number]]: key;};</code></pre><p>遍历联合类型</p><pre><code class="language-ts">// 对于联合类型，extends 语法，会把T中每一个类型都拿出来进行一次判断type MyExclude&lt;T, U&gt; = T extends U ? never : T;// 再来个例子，实现泛型IsUnion&lt;T&gt;，它可以判断T是否为联合类型。T 如果是联合类型，会分成多个子类型和B 比较，然后再判断// B 的所有类型是不是和和T 的子类型一致，这里利用[B] 阻止第二个extends 做类型拆分。type IsUnion&lt;T, B = T&gt; = T extends B ? [B] extends [T] ? false : true : never;// 测试type case1 = IsUnion&lt;string&gt;  // falsetype case2 = IsUnion&lt;string|number&gt;  // truetype case3 = IsUnion&lt;[string|number]&gt;  // false</code></pre><p>字符串类型判断</p><pre><code class="language-ts">// 对于字符串的类型判断，可以用extends 来判断，type TrimsChars = &quot; &quot; | &quot;\n&quot; | &quot;\t&quot;;type TrimLeft&lt;S extends string&gt; = S extends `${TrimsChars}${infer R}`  ? TrimLeft&lt;R&gt;  : S;</code></pre><p>合并数组</p><pre><code class="language-ts">type Concat&lt;T extends any[], U extends any[]&gt; = [...T, ...U]</code></pre><p>生成数组</p><pre><code class="language-ts">type newArr&lt;T extends number, A extends any[] = []&gt; =   A['length'] extends T    ? A    : newArr&lt;T, [...A, '']&gt;type newArr&lt;5&gt; = ['','','','','']    </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise不经常使用的两个函数</title>
      <link href="/posts/90d0eaa2/"/>
      <url>/posts/90d0eaa2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Promise 前端用的比较多，比如<code>Promise.all</code>, <code>Promise.race</code>, 但是promise两个不太常见的函数<code>Promise.allSettled()</code> 和 <code>Promise.any()</code></p></blockquote><h1>Promise.allSettled()</h1><p>Promise.allSettled() 静态方法将一个 Promise 可迭代对象作为输入，并返回一个单独的 Promise。当所有输入的 Promise 都已敲定时（包括传入空的可迭代对象时），返回的 Promise 将被兑现，并带有描述每个 Promise 结果的对象数组。</p><p>Promise.allSettled() 方法是 promise 并发方法之一。在你有多个不依赖于彼此成功完成的异步任务时，或者你总是想知道每个 promise 的结果时，使用 Promise.allSettled() 。</p><p>相比之下，如果任务相互依赖，或者如果你想在任何 promise 被拒绝时立即拒绝，Promise.all() 返回的 Promise 可能更合适。</p><h1>Promise.any()</h1><p>Promise.any() 静态方法将一个 Promise 可迭代对象作为输入，并返回一个 Promise。当输入的任何一个 Promise 兑现时，这个返回的 Promise 将会兑现，并返回第一个兑现的值。当所有输入 Promise 都被拒绝（包括传递了空的可迭代对象）时，它会以一个包含拒绝原因数组的 AggregateError 拒绝。</p><p>Promise.any() 方法是 Promise 并发方法之一。该方法对于返回第一个兑现的 Promise 非常有用。一旦有一个 Promise 兑现，它就会立即返回，因此不会等待其他 Promise 完成。</p><p>与 Promise.all() 返回一个兑现值数组不同的是，我们只会得到一个兑现值（假设至少有一个 Promise 被兑现）。此方法对于那些如果我们只需要一个 Promise 被兑现，但不在意哪一个被兑现的情况更有益。请注意另一个区别：该方法在接收到空的可迭代对象时会拒绝，因为实际上，该可迭代对象不包含任何兑现的项。你可以将 Promise.any() 和 Promise.all() 与 Array.prototype.some() 和 Array.prototype.every() 进行比较。</p><p>同时，与 Promise.race() 返回第一个敲定（无论是兑现还是拒绝）的值不同的是，该方法返回第一个兑现的值。该方法忽略所有被拒绝的 Promise，直到第一个被兑现的 Promise。</p><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> typeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js创建二维数组</title>
      <link href="/posts/f6cbb8a5/"/>
      <url>/posts/f6cbb8a5/</url>
      
        <content type="html"><![CDATA[<p><code>js</code> 创建二维数组不像<code>java</code>那么直白</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个3 * 3 的二维数组</span></span><br><span class="line"><span class="type">int</span> nums[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>之前我都是这样写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>今天看到一个更简洁的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">() =&gt;</span> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>主要是利用了<code>Array.from</code>这个语法<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a></p><p>Array.from(arrayLike)<br>Array.from(arrayLike, mapFn)<br>Array.from(arrayLike, mapFn, thisArg)</p><p>主要是第一个参数，可以传入一个arrayLike对象，这里可以传<code>&#123; length: 3 &#125;</code>，比起我之前的写法，看起来更简洁和可读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">// Expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x + x));</span><br><span class="line"><span class="comment">// Expected output: Array [2, 4, 6]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最简单的css排版代码</title>
      <link href="/posts/ba9e13e/"/>
      <url>/posts/ba9e13e/</url>
      
        <content type="html"><![CDATA[<blockquote><p>RT, 几行简单的css 代码让你的排版看起来not bad, ps（这篇post 是用 github Codespaces 提交的）。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">70ch</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">3em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.75</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3em</span> <span class="number">0</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1d1d1d</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>几个有意思的智力题</title>
      <link href="/posts/b998d6a0/"/>
      <url>/posts/b998d6a0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了锻炼脑力，避免提前患上老年痴呆症，有必要做一些锻炼思维的智力题。🙂这里不给出答案，答案网上都有，只给一点提示。</p></blockquote><h2 id="1-1000瓶药水找毒药"><a class="header-anchor" href="#1-1000瓶药水找毒药">¶</a>1.1000瓶药水找毒药</h2><p>一道经典题，网上都说是微软面试题，但貌似这几年没见微软考过…</p><p>题目描述如下：</p><p>一共 1000 瓶药水，其中 1 瓶有毒药。<br>已知小白鼠喝毒药一天内死<br>若想在一天内找到毒药，最少需要几只小白鼠？</p><p><strong>关键字：二进制</strong></p><h2 id="2-抢30"><a class="header-anchor" href="#2-抢30">¶</a>2.抢30</h2><p>抢 30 是双人游戏<br>游戏规则是：第一个人喊 “ 1 ”或 “ 2 ”，第二个人要接着往下喊一个或两个数，然后再轮到第一个人。两人轮流进行下去。最后喊 30 的人获胜。问喊数字的最佳策略。</p><p><strong>关键字：bash博弈</strong></p><h2 id="3-三个空瓶子"><a class="header-anchor" href="#3-三个空瓶子">¶</a>3.三个空瓶子</h2><p>有三个空瓶子，一个8L，一个5L，一个3L，目前8L的瓶子装满了牛奶。试问，如果在不浪费一滴水和无刻度的情况下，如何测量出4L的牛奶？</p><p><strong>关键字: 模拟，反推</strong></p><h2 id="4-灯泡开关"><a class="header-anchor" href="#4-灯泡开关">¶</a>4.灯泡开关</h2><p>一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。 设计一种算法，对于任意初始状态，使所有灯泡全亮。</p><p><strong>关键字：模拟，反推，从全灭可以恢复到全亮。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> -智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis常见的使用案例</title>
      <link href="/posts/753a7543/"/>
      <url>/posts/753a7543/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>redis</code>除了缓存，还有很多的使用方式，互联网项目的很多功能都是通过<code>redis</code>实现的，今天简单介绍一些。</p></blockquote><h2 id="简单回顾下redis是什么"><a class="header-anchor" href="#简单回顾下redis是什么">¶</a>简单回顾下redis是什么</h2><p><code>Redis</code>是一个使用<code>ANSI C</code>编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。从2015年6月开始，<code>Redis</code>的开发由<code>Redis Labs</code>赞助，而2013年5月至2015年6月期间，其开发由<code>Pivotal</code>赞助。在2013年5月之前，其开发由<code>VMware</code>赞助。根据月度排行网站<code>DB-Engines.com</code>的数据，<code>Redis</code>是最流行的键值对存储数据库。</p><h2 id="redis的特点"><a class="header-anchor" href="#redis的特点">¶</a>redis的特点</h2><ol><li>高性能<br>性能极高 – <code>Redis</code>能读的速度是110000次/s,写的速度是81000次/s 。</li><li>和原生语言无缝的数据结构<br><code>Redis</code>支持二进制案例的 <code>Strings</code>, <code>Lists</code>, <code>Hashes</code>, <code>Sets</code> 及 <code>Ordered Sets</code> 数据类型操作。</li><li>丰富的特性<br>Redis还支持 <code>publish/subscribe</code>, 通知, <code>key</code> 过期等等特性。</li><li>支持持久化<br><code>Redis</code>支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>分布式<br><code>Redis</code>支持数据的备份，即<code>master-slave</code>模式的数据备份。</li><li>高可用<br><code>Redis Sentinel</code> 一个分布式架构，监控各个机器的状态及时作出调整，重新选取主节点。</li></ol><h2 id="五种数据类型和常见用法"><a class="header-anchor" href="#五种数据类型和常见用法">¶</a>五种数据类型和常见用法</h2><h3 id="1-string"><a class="header-anchor" href="#1-string">¶</a>1. <code>string</code></h3><p><code>string</code>在<code>redis</code>里是通过字符数组实现的。你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。value其实不仅是String，也可以是数字。string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h4 id="常见的场景"><a class="header-anchor" href="#常见的场景">¶</a>常见的场景</h4><ol><li><code>json</code>字符串储存缓存</li><li><code>string</code>也可以是一个数字，所以也可以作为计数器，使用<code>INCR</code>命令</li><li><code>redis</code>也支持二进制，所以可以当作一个<code>bitmap</code>,把固定长度的bit位储存数据。</li><li>布隆过滤器，一个很长的二进制向量，作为超大的包含关系的查询。详细点击<a href="https://www.huaweicloud.com/articles/cd70d43549f0a4c36641be61780ab66a.html">这里</a></li><li>分布式锁，比较复杂，可以看下<a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">这里</a>。</li></ol><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">APPEND key value</span><br><span class="line">summary: Append a value to a key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">BITCOUNT key [start end]</span><br><span class="line">summary: Count <span class="built_in">set</span> bits <span class="keyword">in</span> a string</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">BITFIELD key [GET <span class="built_in">type</span> offset] [SET <span class="built_in">type</span> offset value] [INCRBY <span class="built_in">type</span> offset increment] [OVERFLOW WRAP|SAT|FAIL]</span><br><span class="line">summary: Perform arbitrary bitfield <span class="built_in">integer</span> operations on strings</span><br><span class="line">since: 3.2.0</span><br><span class="line"></span><br><span class="line">BITOP operation destkey key [key ...]</span><br><span class="line">summary: Perform bitwise operations between strings</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">BITPOS key bit [start] [end]</span><br><span class="line">summary: Find first bit <span class="built_in">set</span> or clear <span class="keyword">in</span> a string</span><br><span class="line">since: 2.8.7</span><br><span class="line"></span><br><span class="line">DECR key</span><br><span class="line">summary: Decrement the <span class="built_in">integer</span> value of a key by one</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">DECRBY key decrement</span><br><span class="line">summary: Decrement the <span class="built_in">integer</span> value of a key by the given number</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">GET key</span><br><span class="line">summary: Get the value of a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">GETBIT key offset</span><br><span class="line">summary: Returns the bit value at offset <span class="keyword">in</span> the string value stored at key</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">GETRANGE key start end</span><br><span class="line">summary: Get a substring of the string stored at a key</span><br><span class="line">since: 2.4.0</span><br><span class="line"></span><br><span class="line">GETSET key value</span><br><span class="line">summary: Set the string value of a key and <span class="built_in">return</span> its old value</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">INCR key</span><br><span class="line">summary: Increment the <span class="built_in">integer</span> value of a key by one</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">INCRBY key increment</span><br><span class="line">summary: Increment the <span class="built_in">integer</span> value of a key by the given amount</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">INCRBYFLOAT key increment</span><br><span class="line">summary: Increment the <span class="built_in">float</span> value of a key by the given amount</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">MGET key [key ...]</span><br><span class="line">summary: Get the values of all the given keys</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">MSET key value [key value ...]</span><br><span class="line">summary: Set multiple keys to multiple values</span><br><span class="line">since: 1.0.1</span><br><span class="line"></span><br><span class="line">MSETNX key value [key value ...]</span><br><span class="line">summary: Set multiple keys to multiple values, only <span class="keyword">if</span> none of the keys exist</span><br><span class="line">since: 1.0.1</span><br><span class="line"></span><br><span class="line">PSETEX key milliseconds value</span><br><span class="line">summary: Set the value and expiration <span class="keyword">in</span> milliseconds of a key</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br><span class="line">summary: Set the string value of a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SETBIT key offset value</span><br><span class="line">summary: Sets or clears the bit at offset <span class="keyword">in</span> the string value stored at key</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">SETEX key seconds value</span><br><span class="line">summary: Set the value and expiration of a key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">SETNX key value</span><br><span class="line">summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SETRANGE key offset value</span><br><span class="line">summary: Overwrite part of a string at key starting at the specified offset</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">STRLEN key</span><br><span class="line">summary: Get the length of the value stored <span class="keyword">in</span> a key</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-hash"><a class="header-anchor" href="#2-hash">¶</a>2. hash</h3><p>Hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。比如储存用户信息。用户id作为key，姓名，年龄，生日等信息可以维护序列化的对象。</p><h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4><ol><li>存储对象类数据，因此可以存一些结构化的数据，比如购物车，用户基本信息。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HDEL key field [field ...]</span><br><span class="line">summary: Delete one or more <span class="built_in">hash</span> fields</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HEXISTS key field</span><br><span class="line">summary: Determine <span class="keyword">if</span> a <span class="built_in">hash</span> field exists</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HGET key field</span><br><span class="line">summary: Get the value of a <span class="built_in">hash</span> field</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HGETALL key</span><br><span class="line">summary: Get all the fields and values <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HINCRBY key field increment</span><br><span class="line">summary: Increment the <span class="built_in">integer</span> value of a <span class="built_in">hash</span> field by the given number</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line">summary: Increment the <span class="built_in">float</span> value of a <span class="built_in">hash</span> field by the given amount</span><br><span class="line">since: 2.6.0</span><br><span class="line"></span><br><span class="line">HKEYS key</span><br><span class="line">summary: Get all the fields <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HLEN key</span><br><span class="line">summary: Get the number of fields <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HMGET key field [field ...]</span><br><span class="line">summary: Get the values of all the given <span class="built_in">hash</span> fields</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line">summary: Set multiple <span class="built_in">hash</span> fields to multiple values</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate <span class="built_in">hash</span> fields and associated values</span><br><span class="line">since: 2.8.0</span><br><span class="line"></span><br><span class="line">HSET key field value</span><br><span class="line">summary: Set the string value of a <span class="built_in">hash</span> field</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HSETNX key field value</span><br><span class="line">summary: Set the value of a <span class="built_in">hash</span> field, only <span class="keyword">if</span> the field does not exist</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">HSTRLEN key field</span><br><span class="line">summary: Get the length of the value of a <span class="built_in">hash</span> field</span><br><span class="line">since: 3.2.0</span><br><span class="line"></span><br><span class="line">HVALS key</span><br><span class="line">summary: Get all the values <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-list"><a class="header-anchor" href="#3-list">¶</a>3. list</h3><p>list 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>可以作为一个简单的消息队列。</p><h4 id="使用场景-v2"><a class="header-anchor" href="#使用场景-v2">¶</a>使用场景</h4><ol><li>简易消息队列，右(左)边进左(右)边出，用来消费队列里的信息。但是ack机制麻烦，复杂场景还是使用专业的mq。</li><li>作为栈使用，支持右(左)边进右(左)边出。</li><li>用于储存线性数据，比如某个人的关注列表。文章点赞的人的id。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BLPOP key [key ...] <span class="built_in">timeout</span></span><br><span class="line">summary: Remove and get the first element <span class="keyword">in</span> a list, or block <span class="keyword">until</span> one is available</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">BRPOP key [key ...] <span class="built_in">timeout</span></span><br><span class="line">summary: Remove and get the last element <span class="keyword">in</span> a list, or block <span class="keyword">until</span> one is available</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">BRPOPLPUSH <span class="built_in">source</span> destination <span class="built_in">timeout</span></span><br><span class="line">summary: Pop a value from a list, push it to another list and <span class="built_in">return</span> it; or block <span class="keyword">until</span> one is available</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">LINDEX key index</span><br><span class="line">summary: Get an element from a list by its index</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br><span class="line">summary: Insert an element before or after another element <span class="keyword">in</span> a list</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">LLEN key</span><br><span class="line">summary: Get the length of a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LPOP key</span><br><span class="line">summary: Remove and get the first element <span class="keyword">in</span> a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line">summary: Prepend one or multiple values to a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LPUSHX key value</span><br><span class="line">summary: Prepend a value to a list, only <span class="keyword">if</span> the list exists</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">LRANGE key start stop</span><br><span class="line">summary: Get a range of elements from a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LREM key count value</span><br><span class="line">summary: Remove elements from a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LSET key index value</span><br><span class="line">summary: Set the value of an element <span class="keyword">in</span> a list by its index</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">LTRIM key start stop</span><br><span class="line">summary: Trim a list to the specified range</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">RPOP key</span><br><span class="line">summary: Remove and get the last element <span class="keyword">in</span> a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">RPOPLPUSH <span class="built_in">source</span> destination</span><br><span class="line">summary: Remove the last element <span class="keyword">in</span> a list, prepend it to another list and <span class="built_in">return</span> it</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line">summary: Append one or multiple values to a list</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">RPUSHX key value</span><br><span class="line">summary: Append a value to a list, only <span class="keyword">if</span> the list exists</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-set"><a class="header-anchor" href="#4-set">¶</a>4. set</h3><p>set 是string类型的无序集合。集合是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。</p><h3 id="使用场景-v3"><a class="header-anchor" href="#使用场景-v3">¶</a>使用场景</h3><ol><li>去重，多台服务可以放在一个set里去重。</li><li>redis 提供了求交集、并集、差集的操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SADD key member [member ...]</span><br><span class="line">summary: Add one or more members to a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SCARD key</span><br><span class="line">summary: Get the number of members <span class="keyword">in</span> a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line">summary: Subtract multiple sets</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br><span class="line">summary: Subtract multiple sets and store the resulting <span class="built_in">set</span> <span class="keyword">in</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SINTER key [key ...]</span><br><span class="line">summary: Intersect multiple sets</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">summary: Intersect multiple sets and store the resulting <span class="built_in">set</span> <span class="keyword">in</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SISMEMBER key member</span><br><span class="line">summary: Determine <span class="keyword">if</span> a given value is a member of a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SMEMBERS key</span><br><span class="line">summary: Get all the members <span class="keyword">in</span> a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SMOVE <span class="built_in">source</span> destination member</span><br><span class="line">summary: Move a member from one <span class="built_in">set</span> to another</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SPOP key [count]</span><br><span class="line">summary: Remove and <span class="built_in">return</span> one or multiple random members from a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line">summary: Get one or multiple random members from a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SREM key member [member ...]</span><br><span class="line">summary: Remove one or more members from a <span class="built_in">set</span></span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate Set elements</span><br><span class="line">since: 2.8.0</span><br><span class="line"></span><br><span class="line">SUNION key [key ...]</span><br><span class="line">summary: Add multiple sets</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">summary: Add multiple sets and store the resulting <span class="built_in">set</span> <span class="keyword">in</span> a key</span><br><span class="line">since: 1.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-sorted-set"><a class="header-anchor" href="#5-sorted-set">¶</a>5. sorted_set</h3><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 *zadd 命令：*添加元素到集合，元素在集合中存在则更新对应score。set是有序的，根据<code>score</code>排序。</p><h3 id="使用场景-v4"><a class="header-anchor" href="#使用场景-v4">¶</a>使用场景</h3><ol><li>因为自带排序，显示最新的项目列表 ，排行榜相关。</li><li>处理过期项目，比如处理没付款的订单。根据下单时间放进<code>sorted_set</code>，后台任务根据<code>ZRANGE</code>查最近的几条数据，如果过期再回写到数据库。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">summary: Add one or more members to a sorted <span class="built_in">set</span>, or update its score <span class="keyword">if</span> it already exists</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZCARD key</span><br><span class="line">summary: Get the number of members <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZCOUNT key min max</span><br><span class="line">summary: Count the members <span class="keyword">in</span> a sorted <span class="built_in">set</span> with scores within the given values</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZINCRBY key increment member</span><br><span class="line">summary: Increment the score of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">summary: Intersect multiple sorted sets and store the resulting sorted <span class="built_in">set</span> <span class="keyword">in</span> a new key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZLEXCOUNT key min max</span><br><span class="line">summary: Count the number of members <span class="keyword">in</span> a sorted <span class="built_in">set</span> between a given lexicographical range</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by index</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by lexicographical range</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score</span><br><span class="line">since: 1.0.5</span><br><span class="line"></span><br><span class="line">ZRANK key member</span><br><span class="line">summary: Determine the index of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZREM key member [member ...]</span><br><span class="line">summary: Remove one or more members from a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYLEX key min max</span><br><span class="line">summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> between the given lexicographical range</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK key start stop</span><br><span class="line">summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> within the given indexes</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYSCORE key min max</span><br><span class="line">summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> within the given scores</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by index, with scores ordered from high to low</span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">since: 2.8.9</span><br><span class="line"></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score, with scores ordered from high to low</span><br><span class="line">since: 2.2.0</span><br><span class="line"></span><br><span class="line">ZREVRANK key member</span><br><span class="line">summary: Determine the index of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span>, with scores ordered from high to low</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">since: 2.8.0</span><br><span class="line"></span><br><span class="line">ZSCORE key member</span><br><span class="line">summary: Get the score associated with the given member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">since: 1.2.0</span><br><span class="line"></span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">summary: Add multiple sorted sets and store the resulting sorted <span class="built_in">set</span> <span class="keyword">in</span> a new key</span><br><span class="line">since: 2.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他功能"><a class="header-anchor" href="#其他功能">¶</a>其他功能</h2><ol><li>Pub/Sub<br>Redis的Pub/Sub非常非常简单，运行稳定并且快速。可以作为发布订阅使用。<br>2.<code>geo</code><br>储存地理坐标数据，用来实现附近的人功能。</li><li>HyperLogLog<br><code>Redis HyperLogLog</code> 是用来做基数统计的算法，<code>HyperLogLog</code> 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<br>在 <code>Redis</code> 里面，每个 <code>HyperLogLog</code> 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64</code> 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨页面通信的几种方法</title>
      <link href="/posts/97160c27/"/>
      <url>/posts/97160c27/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原来，跨页面通信有这这么多方法</p></blockquote><h2 id="同源页面之间的通信"><a class="header-anchor" href="#同源页面之间的通信">¶</a>同源页面之间的通信</h2><h3 id="localStorage"><a class="header-anchor" href="#localStorage">¶</a>localStorage</h3><p>这个大家都很熟悉了，但是他还有一个storage事件，之前没接触过<br>当 LocalStorage 变化时，会触发storage事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听storage事件即可收到通知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个页面监听事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;storage&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">key</span> === <span class="string">&#x27;ctc-msg&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">newValue</span>);</span><br><span class="line">        <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.<span class="property">msg</span> + <span class="string">&#x27; —— tab &#x27;</span> + data.<span class="property">from</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[Storage I] receive message:&#x27;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 另外一个页面set数据，这里加上事件戳是因为只有真正改变才会触发storage</span></span><br><span class="line">mydata.<span class="property">st</span> = +(<span class="keyword">new</span> <span class="title class_">Date</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;ctc-msg&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(mydata));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IndexedDB"><a class="header-anchor" href="#IndexedDB">¶</a>IndexedDB</h3><p>不多介绍了，就是简单的轮询</p><h3 id="Service-Worker"><a class="header-anchor" href="#Service-Worker">¶</a>Service Worker</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service workers</a> 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。<br>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：<br>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过postMessage传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：<br>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span></span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;../util.shared.js&#x27;</span>, <span class="string">&#x27;ctc&#x27;</span>);</span><br></pre></td></tr></table></figure><p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ../util.shared.js: Shared Worker 代码 */</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="literal">null</span>;</span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">    port.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="comment">// get 指令则返回存储的消息数据</span></span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">data</span>.<span class="property">get</span>) &#123;</span><br><span class="line">            data &amp;&amp; port.<span class="title function_">postMessage</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非 get 指令则存储该消息数据</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            data = event.<span class="property">data</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    port.<span class="title function_">start</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时轮询，发送 get 指令的消息</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    sharedWorker.<span class="property">port</span>.<span class="title function_">postMessage</span>(&#123;<span class="attr">get</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 get 消息的返回数据</span></span><br><span class="line">sharedWorker.<span class="property">port</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = e.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.<span class="property">msg</span> + <span class="string">&#x27; —— tab &#x27;</span> + data.<span class="property">from</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[Shared Worker] receive message:&#x27;</span>, text);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">sharedWorker.<span class="property">port</span>.<span class="title function_">start</span>();</span><br></pre></td></tr></table></figure><p>最后，当要跨页面通信时，只需给 Shared Worker postMessage即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.<span class="property">port</span>.<span class="title function_">postMessage</span>(mydata);</span><br></pre></td></tr></table></figure><p>注意，如果使用addEventListener来添加 Shared Worker 的消息监听，需要显式调用MessagePort.start方法，即上文中的sharedWorker.port.start()；如果使用onmessage绑定监听则不需要。</p><h3 id="BroadCast-Channel"><a class="header-anchor" href="#BroadCast-Channel">¶</a>BroadCast Channel</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API">Broadcast Channel API</a> 可以实现同 源 下浏览器不同窗口，Tab页，frame或者 iframe 下的 浏览器上下文 (通常是同一个网站下不同的页面)之间的简单通讯。</p><p>简单的api展示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接到广播频道,在多个页面注册同一个频道</span></span><br><span class="line"><span class="keyword">var</span> bc = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;test_channel&#x27;</span>);</span><br><span class="line"><span class="comment">// 发送简单消息的示例</span></span><br><span class="line">bc.<span class="title function_">postMessage</span>(<span class="string">&#x27;This is a test message.&#x27;</span>);</span><br><span class="line"><span class="comment">// 简单示例，用于将事件打印到控制台</span></span><br><span class="line">bc.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(ev); &#125;</span><br><span class="line"><span class="comment">// 断开频道连接</span></span><br><span class="line">bc.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure><h2 id="非同源页面之间的通信"><a class="header-anchor" href="#非同源页面之间的通信">¶</a>非同源页面之间的通信</h2><h3 id="利用中间iframe作为brideg"><a class="header-anchor" href="#利用中间iframe作为brideg">¶</a>利用中间iframe作为brideg</h3><p>使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定origin来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<a href="http://sample.com/bridge.html%EF%BC%89%EF%BC%8C%E8%80%8C%E8%BF%99%E4%BA%9B">http://sample.com/bridge.html），而这些</a> iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 业务页面代码 */</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// …… do something</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 业务页面代码发信息 */</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="property">window</span>.<span class="title function_">postMessage</span>(mydata, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="利用websocket"><a class="header-anchor" href="#利用websocket">¶</a>利用websocket</h3><p>利用后端新开一个websocket服务，多个页面都接受服务端的推送，也可以实现同步状态。</p><hr><p>原文地址，本文稍作删改：<br><a href="https://juejin.cn/post/6844903811232825357">https://juejin.cn/post/6844903811232825357</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch使用</title>
      <link href="/posts/5e47ac86/"/>
      <url>/posts/5e47ac86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一次将千万级别的数据库表迁移到Elasticsearch 的过程</p></blockquote><h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>我们有一张千万级别，并且每天都新增将近万条数据，更新也在十几万的业务表，这个业务表可以说是我们的核心业务，因为历史问题，表字段除了基本的字段外，还存了json， 一个字符串可代表多业务， 甚至存了二进制的对象， 同时，我们的运营页面需要根据将近20个查询条件对这个表进行查询，一方面因为数据量大，多个查询条件组合起来，查出数据有时也要十几秒，甚至在一些极端情况下，页面直接超时，用户体验很不好，另一方面，有些字段隐藏在json内部，或者二进制的对象里面，限制了其作为查询条件。</p><h2 id="预研"><a class="header-anchor" href="#预研">¶</a>预研</h2><p>于是我花了两天的时间了解了Elasticsearch 是什么，可以做什么，大概的操作步骤，查询api，以及配套的生态，又花了一天在测试环境搭建了一套elk，就开始了迁移的测试。<br>ps：在这里说明一下<br>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。<br>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志<br>elk当然就是这三部分的组合了。</p><h2 id="用logstash-同步数据"><a class="header-anchor" href="#用logstash-同步数据">¶</a>用logstash 同步数据</h2><p>logstash 本身的配置也不复杂，分为<code>input</code>，<code>filter</code>，<code>output</code> 三部分。<br><code>input</code> 和 <code>output</code>支持各种插件。<br>比如<code>input</code> 支持 <code>mysql</code>，<code>file</code>，<code>http</code>，等等，最新的<code>input</code> 甚至支持<code>Twitter </code>。<br><code>output</code> 支持 <code>elasticsearch</code>，<code>email</code>，<code>rabbitmq</code>等等。<br>查看所有支持的插件可以点击<a href="https://www.elastic.co/guide/en/logstash/7.12/introduction.html">这里</a></p><p>这一步本来是很简单的，因为logstash 本身就支持同步mysql数据到es，只需要简单的配置，加上json的中间filter，就可以完成了，但是就是二进制的数据对象要解析出来有点麻烦，还好logstash支持用ruby作为脚本，于是就需要编写一个ruby脚本，把从mysql里读出来的二进制转化成对象，我们存的二进制是protobuf转化的对象，因此，需要用一个protobuf的库 把二进制转成ruby对象，然后在解析这个对象，分割成不同的字段存入es。<br>首先，我从内部的平台，下载了原始的protobuf文件，然后在公司的编译机上，便成ruby的class文件，但是怎么从二进制解码到对象呢？我又翻看了下logstash的文档，发现他有一个codec的插件是直接支持解码pb对象的，但是这个插件只支持每次解析一行，但是我从mysql读出来的数据，是一行sql插叙结果，里面只有几个字段是二进制的，于是我找到了这个插件<code>logstash-codec-protobuf</code>的github<a href="https://github.com/logstash-plugins/logstash-codec-protobuf">地址</a>，简单看了下源码和<code>api</code>，源码不多加上注释也才700多行，虽然没学过ruby但也大概看出来一些逻辑，看了下他的依赖，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;logstash/codecs/base&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;logstash/util/charset&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;google/protobuf&#x27;</span> <span class="comment"># for protobuf3</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;protocol_buffers&#x27;</span> <span class="comment"># https://github.com/codekitchen/ruby-protocol-buffers, for protobuf2</span></span><br></pre></td></tr></table></figure><p>主要起作用的应该是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;google/protobuf&#x27;</span> <span class="comment"># for protobuf3</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;protocol_buffers</span></span><br></pre></td></tr></table></figure><p>整个代码是一个面向对象的语法， 定义了一个class</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogStash::Codecs::Protobuf</span> &lt; <span class="title class_ inherited__">LogStash::Codecs::Base</span></span><br></pre></td></tr></table></figure><p>里面有<code>register</code>,<code>decode</code>,<code>encode</code> 等方法，看来起作用的就是<code>decode</code> 了，马上拿来放在脚本里面跑了一下，成功从二进制解析得到了ruby对象。</p><p>接下来就简单了，注意细节，对照字段开始同步。大概花了25个小时，就把所有的数据同步到了es,增量的数据，我用<code>updatetime</code>作为查询条件更新。</p><h2 id="用php客户端查询数据"><a class="header-anchor" href="#用php客户端查询数据">¶</a>用php客户端查询数据</h2><p>最后，我用php客户端，通过http调用的形式，使用es查询语法，对数据进行查询，果然快了很多，复杂的查询条件，也能在1s左右查询出来。</p><p>这里要说明的是<code>kibana</code>里面有个devtool的页面，可以在里面写查询语句验证结果，使用起来十分方便。</p><h2 id="遇到的坑"><a class="header-anchor" href="#遇到的坑">¶</a>遇到的坑</h2><p>主要是分页查询的时候，很大的数据量下不能以一般的查询语法，即from to 这种，因为在深度分页的情况下，这种使用方式效率是非常低的，比如from = 5000, size=10， es 需要在各个分片上匹配排序并得到5000*10条有效数据，然后在结果集中取最后10条数据返回。</p><p>我们就遇到了这个问题，先把<code>max_result_window </code>调大了一些，后来用深度分页代替：<br>es 提供了 <code>Scroll API</code> 的方式进行分页读取。原理上是对某次查询生成一个游标 scroll_id ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。scroll_id 的生成可以理解为建立了一个临时的历史快照，在此之后的增删改查等操作不会影响到这个快照的结果。<br>但是这个也不允许随机跳页，适合类似微博那种下拉翻页的场景。</p><p>ps: 关于深度分页优化可以看下<a href="https://juejin.cn/post/6850037275456339975">这里</a></p><h2 id="elk很复杂的"><a class="header-anchor" href="#elk很复杂的">¶</a>elk很复杂的</h2><p>虽然基本符合了使用场景，但是关于elk我感觉还是只了解了皮毛，如何优化，怎么关联查询，怎么设置索引结构更高效，更复杂的查询语句，这些都还没接触到。<br>ps: 网上很多关于性能优化的文章，比如<a href="https://zhuanlan.zhihu.com/p/67362440">这篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2道算法题的优化过程</title>
      <link href="/posts/7e570359/"/>
      <url>/posts/7e570359/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近刷了那么多的算法,感觉自己刚刚有点进步,又被两道简单题搞晕了🙃🙃,彻底暴露了自己对时间复杂度掌握不足的遗漏,因此在这里记录下优化的过程.</p></blockquote><h3 id="第一题"><a class="header-anchor" href="#第一题">¶</a>第一题</h3><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：</p><p>输入：nums = [1,1,1,2,2,3]<br>输出：5, nums = [1,1,2,2,3]<br>解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums = [0,0,1,1,1,1,2,3,3]<br>输出：7, nums = [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。<br>一看到题目,觉得不难,马上开始写代码,就模拟整个过程,几分钟搞定.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> last = nums[len-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums.<span class="property">length</span>-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] === last) &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">2</span>) &#123;</span><br><span class="line">                len--</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> j = i;j&lt;len;j++) &#123;</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            last = nums[i]</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>刚好这几天几个同事都在打卡每日一题,我们交流了一下,我把自己的代码给同事看了看,一个同事立马说,你这个时间复杂度太高了,我仔细看了看代码,确实,循环里面移动数组,大概复杂度O(n^2).</p><p>听了同事的的解法,我顿悟了,原来双指针就好了,快慢指针,慢指针保持长度,快指针每次+1用来检查后面的元素,遇到不同的元素,并且前方已经出现了两个重复的,就覆盖前方慢指针的元素,然后慢指针继续+1</p><p>下面是代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> fast = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast&lt;n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow-<span class="number">2</span>] !== nums[fast]) &#123;</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">        fast++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样时间复杂度就被优化到了O(n),只遍历了一边.<br>经过自己的测试,在长度为999999,三个一组相同的数组的运行测试下,第二种花费大概3ms,而第一种,居然用了100000+ms,相差了3万倍!!!🤯 🤯 🤯 🤯 🤯</p><h3 id="第二题"><a class="header-anchor" href="#第二题">¶</a>第二题</h3><p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1<br>示例 1：</p><p>输入：nums = [2,5,3,5], target = 6</p><p>输出：1</p><p>解释：预算内仅能购买 nums[0] 与 nums[2]。</p><p>示例 2：</p><p>输入：nums = [2,2,1,9], target = 10</p><p>输出：4</p><p>解释：符合预算的采购方案如下：<br>nums[0] + nums[1] = 4<br>nums[0] + nums[2] = 3<br>nums[1] + nums[2] = 3<br>nums[2] + nums[3] = 10</p><p>第一眼看到这个题,心想这么简单的吗?<br>立马又是双层循环遍历一边,果不其然超时了,一看给的测试用例,长度 <code>2 &lt;= nums.length &lt;= 10^5</code><br>考虑到没有负数,于是加了个判断第一个数的长度是否大于target,然而还是超时.<br>想了想,先排下顺序吧,然后二分找到小于target的部分,在这个范围内判断,后来又想,如果target很大怎么办?不还是要遍历很多次吗?<br>想啊想,死掉n个脑细胞,m根头发后,我明白了,在一个顺序的数组里,如果下标i和下标j满足小于target,那么i和其他小于j的其他组合都满足,这个个数是(j-i)个,然后i++继续判断就行了,如果大于target了,就大数的下标,j 向左移动j-- 就行了. 想明白后,才发现已经过去1个小时了.马上动手写代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> purchasePlans = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MOD</span> = <span class="number">1000000007</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a-b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span>  j = nums.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + nums[j] &lt;= target) &#123;</span><br><span class="line">            res+=j-i</span><br><span class="line">            res = res%<span class="variable constant_">MOD</span></span><br><span class="line">            i++</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就O(n)了,同时,不要忘了模MOD.</p><p>注意时间复杂度,不要再写低效率的代码了💪💪💪💪💪</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器兼容性问题</title>
      <link href="/posts/fe80343/"/>
      <url>/posts/fe80343/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个记录日常结局浏览器兼容问题的备忘录</p></blockquote><ol><li>如何查看某个javaScript 对象或者css 属性的兼容性</li></ol><p>到MND搜索需要查看的内容,页面底部提供一份不同平台(比如PC端,手机端,node端)以及不同浏览器进行和其各个历史版本的兼容表格,可以很直观的看到你要用的技术是否支持业务覆盖的浏览器或者平台.</p><ol start="2"><li>浏览器强制用webkit内核<br>国内部分双核浏览器如：360极速浏览器、搜狗浏览器、百度浏览器等等，这些浏览器都号称拥有两个内核，用户可以根据需要自由切换。双核浏览器的2个内个分别为极速内核（webkit内核），兼容内核（trident内核）。使用极速内核浏览器会按照w3c的新标准渲染页面，其结果是渲染速度更快，规范性更好。而兼容内核也并非一无是处，国内很多政府、银行类网站在编写之初考虑了兼容旧版本ie的trident内核，其代码并非为w3c规范的标准，而是浏览器厂商自定义的模式，这类网站则必须使用兼容模式打开，如果使用极速模式打开就会产生布局错乱等问题。</li></ol><p>可以用下面的标签强制浏览器使用极速内核:<br><meta name="renderer" content="webkit"></p><p>也可以使用兼容的写法:<br><meta name="renderer" content="webkit|ie-comp|ie-stand"><br>这里会根据先后顺序,启用支持的内核,不支持也不会</p><ol start="3"><li>重置样式<br>不同的浏览器之间基本样式很不一样，比如IE浏览器使用ie盒子模型，现代浏览器大多使用标准盒子模型。他们之间的宽度计算很不一样。<br>这个时候就需要用reset.css重置一下样式了</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"><span class="comment">/* CSS Document */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">div</span>, <span class="selector-tag">span</span>, applet, <span class="selector-tag">object</span>, <span class="selector-tag">iframe</span>,</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, pre,</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">abbr</span>, acronym, <span class="selector-tag">address</span>, big, <span class="selector-tag">cite</span>, <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">del</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="attribute">font</span>, <span class="selector-tag">img</span>, <span class="selector-tag">ins</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">q</span>, s, <span class="selector-tag">samp</span>,</span><br><span class="line">small, strike, <span class="selector-tag">strong</span>, sub, <span class="selector-tag">sup</span>, tt, <span class="selector-tag">var</span>,</span><br><span class="line"><span class="selector-tag">b</span>, u, <span class="selector-tag">i</span>, center,</span><br><span class="line"><span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">form</span>, <span class="selector-tag">label</span>, <span class="selector-tag">legend</span>,</span><br><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">caption</span>, <span class="selector-tag">tbody</span>, <span class="selector-tag">tfoot</span>, <span class="selector-tag">thead</span>, <span class="selector-tag">tr</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: baseline;</span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ol</span>, <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span> &#123;</span><br><span class="line">    <span class="attribute">quotes</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-pseudo">:before</span>, <span class="selector-tag">blockquote</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:before</span>, <span class="selector-tag">q</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">content</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* remember to define focus styles! */</span></span><br><span class="line"><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* remember to highlight inserts somehow! */</span></span><br><span class="line"><span class="selector-tag">ins</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">del</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tables still need &#x27;cellspacing=&quot;0&quot;&#x27; in the markup */</span></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">    <span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清除浮动 */</span></span><br><span class="line"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">display</span>:block;<span class="attribute">clear</span>:both;<span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;<span class="attribute">visibility</span>:hidden; <span class="attribute">height</span>:<span class="number">0</span>;&#125; </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;zoom:<span class="number">1</span>&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>浏览器类型判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器类型判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">browserType</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> userAgent = navigator.<span class="property">userAgent</span>; <span class="comment">//取得浏览器的userAgent字符串</span></span><br><span class="line">    <span class="keyword">var</span> isOpera = userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Opera&quot;</span>) &gt; -<span class="number">1</span>; <span class="comment">//判断是否Opera浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isIE = <span class="variable language_">window</span>.<span class="property">ActiveXObject</span> || <span class="string">&quot;ActiveXObject&quot;</span> <span class="keyword">in</span> <span class="variable language_">window</span></span><br><span class="line">    <span class="keyword">var</span> isEdge = userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Edge&quot;</span>) &gt; -<span class="number">1</span>; <span class="comment">//判断是否IE的Edge浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isFF = userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Firefox&quot;</span>) &gt; -<span class="number">1</span>; <span class="comment">//判断是否Firefox浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isSafari = userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Safari&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Chrome&quot;</span>) == -<span class="number">1</span>; <span class="comment">//判断是否Safari浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isChrome = userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Chrome&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; userAgent.<span class="title function_">indexOf</span>(<span class="string">&quot;Safari&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; !isEdge; <span class="comment">//判断Chrome浏览器</span></span><br><span class="line">    <span class="keyword">if</span> (isIE) &#123;</span><br><span class="line">        <span class="keyword">var</span> reIE = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;MSIE (\\d+\\.\\d+);&quot;</span>);</span><br><span class="line">        reIE.<span class="title function_">test</span>(userAgent);</span><br><span class="line">        <span class="keyword">var</span> fIEVersion = <span class="built_in">parseFloat</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$1&quot;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (userAgent.<span class="title function_">indexOf</span>(<span class="string">&#x27;MSIE 6.0&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IE6&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IE7&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IE8&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IE9&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fIEVersion == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IE10&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (userAgent.<span class="title function_">toLowerCase</span>().<span class="title function_">match</span>(<span class="regexp">/rv:([\d.]+)\) like gecko/</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IE11&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        &#125;<span class="comment">//IE版本过低</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFF) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FF&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isOpera) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Opera&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSafari) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Safari&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isChrome) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chrome&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEdge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Edge&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>html if 判断浏览器ie版本</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if !IE]&gt; 除IE外都可识别 &lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>~~未完待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promiseA+</title>
      <link href="/posts/d721f59f/"/>
      <url>/posts/d721f59f/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript Promise A+ 规范</p></blockquote><p>译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。</p><p>一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。</p><p>译文术语:</p><p>解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</p><p>拒绝（reject）：指一个 promise 失败时进行的一系列操作。</p><p>终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</p><p>据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</p><p>实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise 实现 遵循promise/A+规范</span></span><br><span class="line"><span class="comment"> * Promise/A+规范译文:</span></span><br><span class="line"><span class="comment"> * https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/#note-4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 三个状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">excutor</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span>; <span class="comment">// 缓存当前promise实例对象</span></span><br><span class="line">    that.<span class="property">status</span> = <span class="variable constant_">PENDING</span>; <span class="comment">// 初始状态</span></span><br><span class="line">    that.<span class="property">value</span> = <span class="literal">undefined</span>; <span class="comment">// fulfilled状态时 返回的信息</span></span><br><span class="line">    that.<span class="property">reason</span> = <span class="literal">undefined</span>; <span class="comment">// rejected状态时 拒绝的原因</span></span><br><span class="line">    that.<span class="property">onFulfilledCallbacks</span> = []; <span class="comment">// 存储fulfilled状态对应的onFulfilled函数</span></span><br><span class="line">    that.<span class="property">onRejectedCallbacks</span> = []; <span class="comment">// 存储rejected状态对应的onRejected函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123; <span class="comment">// value成功态时接收的终值</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么resolve 加setTimeout?</span></span><br><span class="line">        <span class="comment">// 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.</span></span><br><span class="line">        <span class="comment">// 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 调用resolve 回调对应onFulfilled函数</span></span><br><span class="line">            <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="comment">// 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject)</span></span><br><span class="line">                that.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">                that.<span class="property">value</span> = value;</span><br><span class="line">                that.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123; <span class="comment">// reason失败态时接收的拒因</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 调用reject 回调对应onRejected函数</span></span><br><span class="line">            <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">                <span class="comment">// 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject)</span></span><br><span class="line">                that.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">                that.<span class="property">reason</span> = reason;</span><br><span class="line">                that.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">reason</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获在excutor执行器中抛出的异常</span></span><br><span class="line">    <span class="comment">// new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     throw new Error(&#x27;error in excutor&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">excutor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * resolve中的值几种情况：</span></span><br><span class="line"><span class="comment"> * 1.普通值</span></span><br><span class="line"><span class="comment"> * 2.promise对象</span></span><br><span class="line"><span class="comment"> * 3.thenable对象/函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">promise</span>&#125; promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">[type]</span>&#125; x         promise1中onFulfilled的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">[type]</span>&#125; resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">[type]</span>&#125; reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123; <span class="comment">// 如果从onFulfilled中返回的x 就是promise2 就会导致循环引用报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;循环引用&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 避免多次调用</span></span><br><span class="line">    <span class="comment">// 如果x是一个promise对象 （该判断和下面 判断是不是thenable对象重复 所以可有可无）</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123; <span class="comment">// 获得它的终值 继续resolve</span></span><br><span class="line">        <span class="keyword">if</span> (x.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123; <span class="comment">// 如果为等待态需等待直至 x 被执行或拒绝 并解析y值</span></span><br><span class="line">            x.<span class="title function_">then</span>(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">            &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(reason);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 x 已经处于执行态/拒绝态(值已经被解析为普通值)，用相同的值执行传递下去 promise</span></span><br><span class="line">            x.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 x 为对象或者函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span>) || (<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 是否是thenable对象（具有then方法的对象/函数）</span></span><br><span class="line">            <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.<span class="title function_">call</span>(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">reject</span>(reason);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明是一个普通对象/函数</span></span><br><span class="line">                <span class="title function_">resolve</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [注册fulfilled状态/rejected状态对应的回调函数]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">function</span>&#125; onFulfilled fulfilled状态时 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">function</span>&#125; onRejected  rejected状态时 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">function</span>&#125; newPromsie  返回一个新的promise对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> newPromise;</span><br><span class="line">    <span class="comment">// 处理参数默认值 保证参数后续能够继续执行</span></span><br><span class="line">    onFulfilled =</span><br><span class="line">        <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected =</span><br><span class="line">        <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then里面的FULFILLED/REJECTED状态时 为什么要加setTimeout ?</span></span><br><span class="line">    <span class="comment">// 原因:</span></span><br><span class="line">    <span class="comment">// 其一 2.2.4规范 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout</span></span><br><span class="line">    <span class="comment">// 其二 2.2.6规范 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其二 2.2.6规范 也是resolve函数里加setTimeout的原因</span></span><br><span class="line">    <span class="comment">// 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如下面这种情景 多次调用p1.then</span></span><br><span class="line">    <span class="comment">// p1.then((value) =&gt; &#123; // 此时p1.status 由pedding状态 =&gt; fulfilled状态</span></span><br><span class="line">    <span class="comment">//     console.log(value); // resolve</span></span><br><span class="line">    <span class="comment">//     // console.log(p1.status); // fulfilled</span></span><br><span class="line">    <span class="comment">//     p1.then(value =&gt; &#123; // 再次p1.then 这时已经为fulfilled状态 走的是fulfilled状态判断里的逻辑 所以我们也要确保判断里面onFuilled异步执行</span></span><br><span class="line">    <span class="comment">//         console.log(value); // &#x27;resolve&#x27;</span></span><br><span class="line">    <span class="comment">//     &#125;);</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;当前执行栈中同步代码&#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// console.log(&#x27;全局执行栈中同步代码&#x27;);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123; <span class="comment">// 成功态</span></span><br><span class="line">        <span class="keyword">return</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(that.<span class="property">value</span>);</span><br><span class="line">                    <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject); <span class="comment">// 新的promise resolve 上一个onFulfilled的返回值</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e); <span class="comment">// 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123; <span class="comment">// 失败态</span></span><br><span class="line">        <span class="keyword">return</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(that.<span class="property">reason</span>);</span><br><span class="line">                    <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123; <span class="comment">// 等待态</span></span><br><span class="line">        <span class="comment">// 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span></span><br><span class="line">        <span class="keyword">return</span> newPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            that.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(value);</span><br><span class="line">                    <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            that.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(reason);</span><br><span class="line">                    <span class="title function_">resolvePromise</span>(newPromise, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise.all Promise进行并行处理</span></span><br><span class="line"><span class="comment"> * 参数: promise对象组成的数组作为参数</span></span><br><span class="line"><span class="comment"> * 返回值: 返回一个Promise实例</span></span><br><span class="line"><span class="comment"> * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> done = <span class="title function_">gen</span>(promises.<span class="property">length</span>, resolve);</span><br><span class="line">        promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">done</span>(index, value)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params">length, resolve</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">i, value</span>) &#123;</span><br><span class="line">        values[i] = value;</span><br><span class="line">        <span class="keyword">if</span> (++count === length) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">            <span class="title function_">resolve</span>(values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise.race</span></span><br><span class="line"><span class="comment"> * 参数: 接收 promise对象组成的数组作为参数</span></span><br><span class="line"><span class="comment"> * 返回值: 返回一个Promise实例</span></span><br><span class="line"><span class="comment"> * 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理(取决于哪一个更快)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            promise.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于promise方法链时 捕获前面onFulfilled/onRejected抛出的异常</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span> (<span class="params">onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于Promise实现Deferred的</span></span><br><span class="line"><span class="comment"> * Deferred和Promise的关系</span></span><br><span class="line"><span class="comment"> * - Deferred 拥有 Promise</span></span><br><span class="line"><span class="comment"> * - Deferred 具备对 Promise的状态进行操作的特权方法（resolve reject）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *参考jQuery.Deferred</span></span><br><span class="line"><span class="comment"> *url: http://api.jquery.com/category/deferred-object/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">deferred</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 延迟对象</span></span><br><span class="line">    <span class="keyword">let</span> defer = &#123;&#125;;</span><br><span class="line">    defer.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        defer.<span class="property">resolve</span> = resolve;</span><br><span class="line">        defer.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise/A+规范测试</span></span><br><span class="line"><span class="comment"> * npm i -g promises-aplus-tests</span></span><br><span class="line"><span class="comment"> * promises-aplus-tests Promise.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Promise</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>来源:<br><a href="https://www.ituring.com.cn/article/66566">https://www.ituring.com.cn/article/66566</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3-new-feature</title>
      <link href="/posts/20a24eb5/"/>
      <url>/posts/20a24eb5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结一下最近一段时间学习 vue3 的收获</p></blockquote><h2 id="功能方面"><a class="header-anchor" href="#功能方面">¶</a>功能方面</h2><h4 id="Composition-API-组合API"><a class="header-anchor" href="#Composition-API-组合API">¶</a>Composition API (组合API)</h4><p>Composition API 的灵感来自于 React Hooks ，是比 mixin 更强大的存在。它可以提高代码逻辑的可复用性，从而实现与模板的无关性；同时函数式的编程使代码的可压缩性更强。另外，把 Reactivity 模块独立开来，意味着 Vue3.0 的响应式模块可以与其他框架相组合。<br>官方例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鼠标位置侦听逻辑 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">update</span> = e =&gt; &#123;</span><br><span class="line">            state.<span class="property">x</span> = e.<span class="property">pageX</span></span><br><span class="line">            state.<span class="property">y</span> = e.<span class="property">pageY</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, update)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">toRefs</span>(state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，就是把相关的逻辑单独拿出来提高代码复用</p><h4 id="全局挂载-配置API更改"><a class="header-anchor" href="#全局挂载-配置API更改">¶</a>全局挂载/配置API更改</h4><p>vue2 使用 new Vue 创建实例，通过全局设置config配置vue的可选配置。<br>vue3 使用 createApp 定义的某个 Vue 程序。它可以使你的代码更易于理解，并且不易出现由第三方插件引发的意外问题。目前，如果某些第三方解决方案正在修改 Vue 对象，那么它可能会以意想不到的方式（尤其是全局混合）影响你的程序，而 Vue 3 则没有这个问题.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="property">config</span>.<span class="property">ignoredElements</span> = [<span class="regexp">/^app-/</span>]</span><br><span class="line">app.<span class="title function_">use</span>(<span class="comment">/* ... */</span>)</span><br><span class="line">app.<span class="title function_">mixin</span>(<span class="comment">/* ... */</span>)</span><br><span class="line">app.<span class="title function_">component</span>(<span class="comment">/* ... */</span>)</span><br><span class="line">app.<span class="title function_">directive</span>(<span class="comment">/* ... */</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Fragments-片段"><a class="header-anchor" href="#Fragments-片段">¶</a>Fragments(片段)</h4><p>在书写vue2时，由于组件必须只有一个根节点，很多时候会添加一些没有意义的节点用于包裹。Fragment组件就是用于解决这个问题的（这和React中的Fragment组件是一样的）。</p><h4 id="Suspense"><a class="header-anchor" href="#Suspense">¶</a>Suspense</h4><p>同样的，这和React中的Supense是一样的。Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Suspended-component</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">    Loading...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="v-model-支持多个"><a class="header-anchor" href="#v-model-支持多个">¶</a>v-model 支持多个</h4><p>在 3.x 版本中，在自定义组件上使用 v-model 相当于传递了一个 modelValue 属性以及触发一个 update:modelValue 事件。<br>如果要改变绑定的属性名，只需要给 v-model 传递一个参数就好了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">KyrieInput</span> <span class="attr">v-model:title</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">KyrieInput</span> <span class="attr">:title</span>=<span class="string">&quot;name&quot;</span> @<span class="attr">update:title</span>=<span class="string">&quot;name = $event&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个写法还彻底代替了 .sync 修饰符，并且支持统一组件绑定多个 v-model</p><h4 id="Portals"><a class="header-anchor" href="#Portals">¶</a>Portals</h4><p>Teleport其实就是React中的Portal。Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。</p><h2 id="实现逻辑重大更改"><a class="header-anchor" href="#实现逻辑重大更改">¶</a>实现逻辑重大更改</h2><h4 id="响应式原理"><a class="header-anchor" href="#响应式原理">¶</a>响应式原理</h4><p>Object.defineProperty -&gt; Proxy<br>Object.defineProperty是一个相对比较昂贵的操作，因为它直接操作对象的属性，颗粒度比较小。将它替换为es6的Proxy，在目标对象之上架了一层拦截，代理的是对象而不是对象的属性。这样可以将原本对对象属性的操作变为对整个对象的操作，颗粒度变大。</p><p>javascript引擎在解析的时候希望对象的结构越稳定越好，如果对象一直在变，可优化性降低，proxy不需要对原始对象做太多操作。</p><p>同时，有了Proxy，就不用考虑新增属性的响应行为了，是时候要跟$set说声再见了。</p><h2 id="性能方面"><a class="header-anchor" href="#性能方面">¶</a>性能方面</h2><p>双向响应原理由Object.defineProperty改为基于ES6的Proxy，使其颗粒度更大，速度更快，且消除了之前存在的警告；<br>重写了 Vdom ，突破了 Vdom 的性能瓶颈<br>进行了模板编译的优化<br>进行了更加高效的组件初始化</p><h4 id="支持tree-shaking-更加解耦的代码结构"><a class="header-anchor" href="#支持tree-shaking-更加解耦的代码结构">¶</a>支持tree-shaking , 更加解耦的代码结构</h4><p>支持了 tree-shaking （剪枝）：像修剪树叶一样把不需要的东西给修剪掉，使 Vue3 的体积更小。</p><p>需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半（13kb）。哪怕把所有的功能都引入进来也只有23kb，依然比 Vue2.x 更小。像 keep-alive 、 transition 甚至 v-for 等功能都可以按需引入。</p><h4 id="模板性能提升"><a class="header-anchor" href="#模板性能提升">¶</a>模板性能提升</h4><p>在之前的VDOM中，如果msg值发生改变，整个模版中的所有元素都需要重新渲染。但在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 /* Text*/ PatchFlag。只能带patchFlag 的 Node 才被认为是动态的元素，会被追踪属性的修改。并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。<br>每一个Block中的节点，就算很深，也是直接跟Block一层绑定的，可以直接跳转到动态节点而不需要逐个逐层遍历。<br>既有VDOM的灵活性，又有性能保证。<br>vue3 使用 hoistStatic 静态节点提升<br>当使用hoistStatic时，所有 静态的节点都被提升到render方法之外。这意味着，他们只会在应用启动的时候被创建一次，而后随着每次的渲染被不停的复用。</p><h4 id="时间分片"><a class="header-anchor" href="#时间分片">¶</a>时间分片</h4><p>在动态节点和数据的量都很大时，那么在数据更新时，js线程就会用很长的时间来执行vdom的相关计算，如果超过了16ms，造成交互或动画等等卡顿现象。而时间分片就是把vdom的大量计算分成多个小任务，保证每个小任务在16ms内执行完，从而不会阻塞用户交互，避免卡顿现象。<br>然鹅，此功能还未包含在vue3的更新中。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/147022323">https://zhuanlan.zhihu.com/p/147022323</a><br><a href="https://www.jianshu.com/p/1d2846f2a855">https://www.jianshu.com/p/1d2846f2a855</a><br><a href="https://v3.vuejs.org/">https://v3.vuejs.org/</a><br><a href="https://segmentfault.com/a/1190000024580501">https://segmentfault.com/a/1190000024580501</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启网页3D效果之旅</title>
      <link href="/posts/3d46f50c/"/>
      <url>/posts/3d46f50c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上古时代，当<code>html</code>语言和<code>http</code>协议刚被发明出来时，这些专家们也许怎么也想不到，当初发明来共享文本的技术如今统治了几乎整个互联网行业。当第一个网页被打开时，上面只有简陋的一个表单，甚至做一个简单的过渡变色效果，都要借用<code>java Applet</code>，后来要借助<code>javascript</code>。短短十几年过去，现在有了<code>css3</code>，你只需定义简单的<code>transition</code>,就可以实现各种神奇的过渡效果。</p></blockquote><p>本文不是介绍<code>css3</code>动画以及用法的，因此需要读者预先了<code>transition</code>,<code>transform</code>等属性。</p><p>###　回顾下<code>CSS3</code>的基础属性</p><h4 id="1-transition"><a class="header-anchor" href="#1-transition">¶</a>1.<code>transition</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>是被用到最多的也是最简单的<code>CSS3</code>动画类型，如果你想实现鼠标划过更改背景色的功能，用<code>transition</code>是最简单的方式。</p><pre><code class="language-html">&lt;button&gt;会变色的按钮&lt;/button&gt;</code></pre><pre><code class="language-css">button {  transition: all 0.8s ease;  background-color: red;}button:hover {  background-color: #eeeeee;}</code></pre><p>下面是效果：</p><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master/img/1.gif" alt="gif"></p><p><strong>transition</strong> <a href="https://developer.mozilla.org/en/CSS" target="_blank" rel="noopener">CSS</a> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property" target="_blank" rel="noopener"><code>transition-property</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration" target="_blank" rel="noopener"><code>transition-duration</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function" target="_blank" rel="noopener"><code>transition-timing-function</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay" target="_blank" rel="noopener"><code>transition-delay</code></a> 的一个<a href="https://developer.mozilla.org/en-US/docs/CSS/Shorthand_properties" target="_blank" rel="noopener">简写属性</a>。分别是可变换属性，持续时间，变换的过度函数(就是变换的加速度曲线)，效果生效的延时。</p><p>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition" target="_blank" rel="noopener">Transition</a>的更多<code>API</code>，请查看<code>MDN</code>的文档。</p><h4 id="2-transform"><a class="header-anchor" href="#2-transform">¶</a>2.<code>transform</code></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="noopener">transform</a>是执行元素旋转，缩放，位移，倾斜的<code>css</code>属性，它是通过修改视觉上的坐标空间实现的。</p><p>⚠️ 只能转换盒子模型定位的元素。</p><ul><li>旋转<br><code>rotate(a)</code><br>a 是一种<angle>，表示旋转的角度，比如<code>30deg</code>。 正角度表示了顺时针的旋转，负角度表示逆时针的旋转。</angle></li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;rotated&quot;&gt;旋转45度&lt;/div&gt;&lt;div class=&quot;rotated2&quot;&gt;旋转90度&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;}.rotated {  transform: rotate(45deg);  background-color: pink;}.rotated2 {  transform: rotate(90deg);  background-color: blue;  color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/2.gif" alt="gif"></p><ul><li>缩放<br><code>scale(a,b,c)</code><br><em>单一数值</em><br>单一的数值即指定了一个缩放系数，同时作用于 X 轴和 Y 轴让该元素进行缩放，相当于指定了单个值的 scale()(2D 缩放)函数。<br><em>两个长度/百分比值</em><br>两个数值即分别指定了 2D 比例的 X 轴和 Y 轴的缩放系数，相当于指定了两个值的 scale()（2D 缩放）函数。<br><em>三个长度/百分比值</em><br>三个数值即分别指定了 3D 比例的 X 轴、Y 轴和 Z 轴的缩放系数. 相当于一个 scale3d()函数。<br>none<br>指定不进行缩放。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;scale&quot;&gt;大2倍&lt;/div&gt;&lt;div class=&quot;scale2&quot;&gt;水平1.5倍，垂直2倍&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;  text-align: center;  transform-origin: 0 0;}.scale {  transform: scale(2);  background-color: pink;}.scale2 {  transform: scale(1.5, 2);  background-color: blue;  color: #ffffff;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/3.gif" alt="gif"></p><ul><li>位移<br><code>translate(x,y)</code><br>x,y 分别是 x,y 轴移动的距离。</li></ul><pre><code class="language-html">&lt;div&gt;正常&lt;/div&gt;&lt;div class=&quot;translate&quot;&gt;右，下移30px&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;  text-align: center;  transform-origin: 0 0;}.translate {  transform: translate(30px, 30px);  background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/4.gif" alt="gif"></p><ul><li>倾斜</li></ul><p><code>skew(x-angle,y-angle)</code><br>定义沿着 X 和 Y 轴的 2D 倾斜转换。</p><pre><code class="language-html">&lt;div&gt;Normal&lt;/div&gt;&lt;div class=&quot;skewed&quot;&gt;Skewed&lt;/div&gt;</code></pre><pre><code class="language-css">div {  width: 80px;  height: 80px;  background-color: skyblue;}.skewed {  transform: skew(10deg); /* Equal to skewX(10deg) */  background-color: pink;}</code></pre><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/5.gif" alt="gif"></p><h4 id="3-animation"><a class="header-anchor" href="#3-animation">¶</a>3.<code>animation</code></h4><p>我们可以把<code>transition</code>和<code>transform</code> 结合在一起使用，就实现动感十足的 html 页面。<br>但是，<code>transition</code>只能实现开始和结束的状态，并且只能“动一次”。</p><p>还有更加强大的<code>animation</code>属性，可以制作不间断，存在中间状态的动画。</p><p>💥 这里穿插介绍一个<code>animation</code>动画库，<a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">https://daneden.github.io/animate.css/</a></p><p><code>animate.css</code>里面实现了很多常见的淡入淡出，方向移动的动画，可以看下源码，然后自己实现动画的时候就有头绪了。</p><p>下面是一个简单的 fadeout 效果的源代码</p><pre><code class="language-css">@keyframes fadeOutDown {  from {    opacity: 1;  }  to {    opacity: 0;    transform: translate3d(0, 100%, 0);  }}</code></pre><p>点击<code>animate.css</code>官网可以查看更多的效果哦。<img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master/img/6.gif" alt="gif"></p><p>理论上，任何单独的<code>css</code>属性都可以拿来做动画，但是注意一点🙉从无到有，不要用<code>display:none</code>,应该用<code>opacity</code>属性。</p><p>然后是<code>animate</code>的属性，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a> <strong>animation</strong> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener"><code>animation-name</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration" target="_blank" rel="noopener"><code>animation-duration</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function" target="_blank" rel="noopener"><code>animation-timing-function</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay" target="_blank" rel="noopener"><code>animation-delay</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count" target="_blank" rel="noopener"><code>animation-iteration-count</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction" target="_blank" rel="noopener"><code>animation-direction</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode" target="_blank" rel="noopener"><code>animation-fill-mode</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state" target="_blank" rel="noopener"><code>animation-play-state</code></a> 属性的一个简写属性形式。</p><p>这里不一一介绍了。</p><h1></h1><h3 id="进入主题-transform的3d效果"><a class="header-anchor" href="#进入主题-transform的3d效果">¶</a>进入主题–<code>transform</code>的<code>3D</code>效果</h3><p>☑️ 网页的<code>3D</code>坐标系：</p><p><img src="https://raw.githubusercontent.com/zzz1220/imageUrl/master//img/1328957-20190425135458622-1593901679.jpg" alt></p><p>如上图，网格就是网页的坐标系。有了这张图，就可以很轻松的想到如何运用<code>css</code>的属性得到想要的效果。</p><h4 id="1-如何使用3d"><a class="header-anchor" href="#1-如何使用3d">¶</a>1.如何使用<code>3d</code></h4><p><code>transform</code>的<code>translate</code>,<code>scale</code>,<code>rotate</code>都有<code>3D</code>效果。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 转化。</td></tr><tr><td>translateX(<em>x</em>)</td><td>定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td>translateY(<em>y</em>)</td><td>定义 3D 转化，仅使用用于 Y 轴的值。</td></tr><tr><td>translateZ(<em>z</em>)</td><td>定义 3D 转化，仅使用用于 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 缩放转换。</td></tr><tr><td>scaleX(<em>x</em>)</td><td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td>scaleY(<em>y</em>)</td><td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td></tr><tr><td>scaleZ(<em>z</em>)</td><td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td></tr></tbody></table><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td>定义 3D 旋转。</td></tr><tr><td>rotateX(<em>angle</em>)</td><td>定义沿 X 轴的 3D 旋转。</td></tr><tr><td>rotateY(<em>angle</em>)</td><td>定义沿 Y 轴的 3D 旋转。</td></tr><tr><td>rotateZ(<em>angle</em>)</td><td>定义沿 Z 轴的 3D 旋转。</td></tr></tbody></table><p>也可以用</p><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr></tbody></table><p>下面是 3D 变换的例子</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/zzz1220/se45nykp/9//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>上面可以看出来，<code>div</code>脱离了平面，但是效果却仿佛还是平面的，因为我们缺少定义了一个关键的属性：</p><p>🏷<code>persspective</code>给元素加上<code>3D</code>透视(近大远小)的效果。</p><pre><code class="language-css">transform: perspective(600px); // 加在子元素上，给单个元素添加透视/**或者**/perspective: 600px; // 加在父元素上，所有的子元素共享一个3D空间</code></pre><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/zzz1220/oy0rwgh7/32//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>看上面的例子，我们可以看出，给单个元素添加，每个元素都有自己的透视空间。</p><p>🏷<code>perspective-orgin</code>默认的变换点都是元素的中心点，如果你想以其他的位置为变换点，那就可以用这个属性来做调整。</p><p>就像<code>transform-origin</code>在 2D 变换里面设置变换中心点一样。也可以认为是元素的底部位置。</p><p>🏷<code>transform-style</code>这个参数用来共享父元素的 3D 空间。</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">flat</td><td style="text-align:left">表示所有子元素在 2D 平面呈现。</td></tr><tr><td style="text-align:left">preserve-3d</td><td style="text-align:left">表示所有子元素在 3D 空间中呈现。</td></tr></tbody></table><p>🏷<code>backface-visibility</code>可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当 backface-visibility 设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。</p><h4 id="2-3d和硬件加速"><a class="header-anchor" href="#2-3d和硬件加速">¶</a>2.<code>3d</code>和硬件加速</h4><p>动画卡顿是在移动 web 开发时经常遇到的问题，解决这个问题一般会用到<strong>css3 硬件加速</strong>。</p><p>❔什么是硬件加速？</p><p>DOM 树和 CSS 结合后形成渲染树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到 GPU 形成渲染纹理。GPU 中 transform 是不会触发 repaint 的，这一点非常类似 3D 绘图功能，最终这些使用 transform 的图层都会由[独立的合成器进程进行处理]。<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p><p>因此，最简单的开启硬件加速的方法就是设置<code>translateZ(0)</code>。</p><p>但是，开启硬件加速后，会加快用电，并且不合适的使用硬件加速，会造成页面卡顿。</p><p>参考：<a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a> 看下<code>index</code>属性造成不该在复合层（composited layer）中的元素造成页面卡顿的例子。</p><h4 id="3-3d动画的一个实例"><a class="header-anchor" href="#3-3d动画的一个实例">¶</a>3. <code>3d</code>动画的一个实例</h4><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/zzz1220/tj1of0m5//embedded/html,css,result/light" frameborder="0" allowfullscreen></iframe><p>利用<code>translate</code> 和 <code>rotate</code> 制作的一个骰子。</p><p>代码来源：</p><p><a href="https://www.cnblogs.com/zhangnan35/p/10709876.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangnan35/p/10709876.html</a></p><p>参考：</p><p><a href="https://www.jianshu.com/p/f8b1d6e598db" target="_blank" rel="noopener">https://www.jianshu.com/p/f8b1d6e598db</a></p><p><a href="http://beiyuu.com/css3-animation" target="_blank" rel="noopener">http://beiyuu.com/css3-animation</a></p><p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="noopener">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器的简单实现（下）</title>
      <link href="/posts/72b1723d/"/>
      <url>/posts/72b1723d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上文介绍了装饰模式，装饰器语法，今天继续说一下怎么用javascript实现自定义装饰器。</p></blockquote><h3 id="启用装饰器语法"><a class="header-anchor" href="#启用装饰器语法">¶</a>启用装饰器语法</h3><p>目前<code>decorator</code>语法只是题案，想要使用装饰器，需要安装<code>babel</code>和<code>webpack</code>并结合<code>babel/plugin-proposal-decorators</code> 插件。</p><p>关于如何配置请参考<code>babel</code>插件的配置文档。</p><p>或者你也可以直接到 <a href="https://babeljs.io/repl/">https://babeljs.io/repl/</a> 这个地址编写代码，它提供了一个在线的<code>repl</code>环境，可以直接运行<code>es6</code>代码,记得勾选左侧的<code>Experimental</code>来启用装饰器语法。</p><p>🔑 <code>es2015</code>,<code>es2016</code>,<code>es2017</code>和<code>es6</code>之间的关系：</p><blockquote><p>ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p></blockquote><h3 id="类装饰器，方法装饰器和属性装饰器"><a class="header-anchor" href="#类装饰器，方法装饰器和属性装饰器">¶</a>类装饰器，方法装饰器和属性装饰器</h3><h5 id="类装饰器"><a class="header-anchor" href="#类装饰器">¶</a>类装饰器</h5><p>类装饰器就是用来修改类的行为，它标注在类定义的上方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">target</span>) &#123; <span class="comment">// target 就是被装饰的类</span></span><br><span class="line">  target.<span class="property">isTestable</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyTestableClass</span>.<span class="property">isTestable</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这是一个简单的类装饰器，它给被装饰的类添加了一个<code>isTestable</code>的静态属性。</p><p>上面是个简单的例子，下面来个稍微复杂的。<br>想一下，如果我们想给装饰器传参数，要怎么做？熟悉高阶函数的同学一定会立刻想到，函数可以返回函数，只要在装饰器函数外面再加一层函数就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">isTrue</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">target.<span class="property">isTestable</span> = isTrue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTestableClass</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyTestableClass</span>.<span class="property">isTestable</span>  <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是给类添加静态属性，如果想给实例添加属性，需要把属性添加在<code>prototype</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">isTrue</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isTestable</span> = isTrue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔑 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><p>接下来来个稍微复杂一点的例子，用装饰器实现<code>mixin</code>,<br>🔑 mixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mixin</span>(<span class="params">foo</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target.<span class="property"><span class="keyword">prototype</span></span>,foo) <span class="comment">// Onject.assign 是es6里面的Object的新函数，用来把第二个参数的属性合并到第一个参数上 因为这里传入的是类（也就是构造函数），想要在实例上添加属性，需要合并到原型对象上。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line"><span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">mixin</span>(<span class="title class_">Foo</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Target</span>().<span class="title function_">sayHi</span>()</span><br><span class="line"><span class="comment">// Hi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有了装饰器，之前那些烦人的样板函数就可以用装饰器代替了，比如我们用<code>redux</code>和<code>react</code>时，需要把<code>ui</code>组件和逻辑组件合并，经常需要写下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyReactComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">MyReactComponent</span>);</span><br></pre></td></tr></table></figure><p>有了装饰器，就可以改写上面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyReactComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="方法和属性的装饰"><a class="header-anchor" href="#方法和属性的装饰">¶</a>方法和属性的装饰</h5><p>上面的装饰器定义函数我们只用到了一个参数，实际上，在装饰类的属性/方法时他有三个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* target 被装饰的类的原型对象,需要注意，装饰class和class的属性，第一个参数是不一样的，装饰class时，是构造函数，也就是类本身</span></span><br><span class="line"><span class="comment">* key 要修饰的属性名</span></span><br><span class="line"><span class="comment">* descriptor 该属性的描述对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decorator</span>(<span class="params">target,key,descriptor</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>🔑 关于描述对象，不熟悉的可以去看<code>js高级程序设计</code>关于 <code>defineProperty</code> 和 <code>defineProperties</code>的介绍，这两个方法就是用来定义和修改对象的内部属性。<br>举一个常见的例子，在每次函数执行前后，把函数的参数和结果打印出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target,key,descriptor</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> old = descriptor.<span class="property">value</span></span><br><span class="line">descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`call <span class="subst">$&#123;key&#125;</span> with,`</span>,...args)</span><br><span class="line"><span class="keyword">const</span> result = old.<span class="title function_">call</span>(<span class="variable language_">this</span>,...args)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">@log</span><br><span class="line"><span class="title function_">add</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> util = <span class="keyword">new</span> <span class="title class_">Util</span>()</span><br><span class="line">util.<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 这时，控制台会打印出日志</span></span><br><span class="line"><span class="comment">// call add with, 1 2</span></span><br><span class="line"><span class="comment">// result is 3</span></span><br></pre></td></tr></table></figure><p>来一个可缓存的装饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cacheable</span>(<span class="params">target,key,descriptor</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> old = descriptor.<span class="property">value</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">typeof</span> old !== <span class="string">&#x27;function&#x27;</span> ) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;must be a function&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args)</span><br><span class="line"><span class="keyword">if</span>(cache[key]) &#123;</span><br><span class="line"><span class="keyword">return</span> cache[key]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cache[key] = old.<span class="title function_">call</span>(<span class="variable language_">this</span>,...args)</span><br><span class="line"><span class="keyword">return</span> cache[key]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">@cacheable</span><br><span class="line"><span class="title function_">add</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add&quot;</span>,a,b)</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> util = <span class="keyword">new</span> <span class="title class_">Util</span>()</span><br><span class="line">util.<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">util.<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">util.<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 只有第一次运行会打印出 add 1 2</span></span><br></pre></td></tr></table></figure><p>同样的，我们也可以实现属性上的装饰器，比如实现一个类似<code>java</code>包装类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">num</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = num</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">display</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`this is a boxing value , the value is <span class="subst">$&#123;<span class="variable language_">this</span>.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">boxing</span>(<span class="params">target,key,descriptor</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> v = descriptor.<span class="property">initializer</span> &amp;&amp; descriptor.<span class="property">initializer</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    v= <span class="keyword">new</span> <span class="title class_">Integer</span>(v)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">                v = <span class="keyword">new</span> <span class="title class_">Integer</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span> &#123;</span><br><span class="line"></span><br><span class="line">@boxing</span><br><span class="line">a=<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> number = <span class="keyword">new</span> <span class="title class_">Number</span>()</span><br><span class="line">number.<span class="property">a</span>.<span class="title function_">display</span>()</span><br><span class="line"><span class="comment">// this is a boxing value , the value is 2</span></span><br><span class="line">number.<span class="property">a</span> = <span class="number">4</span></span><br><span class="line">number.<span class="property">a</span>.<span class="title function_">display</span>()</span><br><span class="line"><span class="comment">// this is a boxing value , the value is 4</span></span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个简单的包装<code>Integer</code>。</p><p>如果我们每次赋值的时候，都希望检查一下数据类型，可以这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">type</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target,key,descriptor</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> v = descriptor.<span class="property">initializer</span> &amp;&amp; descriptor.<span class="property">initializer</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> c !== type) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">v = c</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方库"><a class="header-anchor" href="#第三方库">¶</a>第三方库</h3><p><code>core-decorators.js</code>是一个第三方模块，提供了一些常见的装饰器<br>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @autobind</span></span><br><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  @autobind</span><br><span class="line">  <span class="title function_">getPerson</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.<span class="property">getPerson</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPerson</span>() === person;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @readonly</span></span><br><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">&#x27;core-decorators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meal</span> &#123;</span><br><span class="line">  @readonly</span><br><span class="line">  entree = <span class="string">&#x27;steak&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dinner = <span class="keyword">new</span> <span class="title class_">Meal</span>();</span><br><span class="line">dinner.<span class="property">entree</span> = <span class="string">&#x27;salmon&#x27;</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property &#x27;entree&#x27; of [object Object]</span></span><br></pre></td></tr></table></figure><p>还有更多不再阐述。</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>上文只是简单对装饰器模式做了基本原理的解释和简单demo，具体在实战中如何应用，还需要很多其他的经验，比如多个装饰器嵌套如何使用，如何利用<code>proxy</code>实现装饰器，在上文中都没提及，在接下来的博文里，会完整的实现一个具有实际意义的装饰器例子。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器的简单实现（上）</title>
      <link href="/posts/72b172aa/"/>
      <url>/posts/72b172aa/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>es7</code>为<code>javascript</code>添加了激动人心的新特性----装饰器，不过<code>Typrscript</code>早就支持了装饰器了，装饰器也不是<code>ts</code>特有的语法，实际上<code>python</code>也有装饰器，在<code>oop</code>语言里面，一直都有装饰器模式，也称为<code>decorator</code>，不过都是从语言层面，通过继承和组合实现，现在，我们可以通过语法层面直接实现装饰器了。</p></blockquote><h3 id="什么是装饰器模式"><a class="header-anchor" href="#什么是装饰器模式">¶</a>什么是装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p><code>java</code>里面的装饰器模式:</p><p>参考这个地址：<a href="https://github.com/iluwatar/java-design-patterns/tree/master/decorator"><strong>decorator</strong></a></p><p>🔼上面的地址是<code>github</code>上一个很有名的各种设计模式的<code>java</code>实现。</p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p></blockquote><p>也就是说：动态的将附加职责添加到对象上。装饰器模式为子类化提供了灵活的代替和扩展的功能。</p><p>举个例子：</p><p>我们小时候都打过<code>cs</code>，每个警察或者劫匪都可以拿一把武器，或者是<code>AK47</code>，或者是<code>m16</code>，为了更换武器，我们没必要去创造新的角色实例，可以用装饰器动态的用武器装饰他。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个角色接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getAttackPower</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Police</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>&#123;</span><br><span class="line">        Systom.out.print(<span class="string">&quot;I&#x27;m attacking you&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAttackPower</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">// 战斗力只有5的渣渣</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AkPolice</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 提供构造函数来对目标进行包装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AkPolice</span><span class="params">(Police decorted)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decorted = decorted; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.decorted.attack()</span><br><span class="line">        Systom.out.print(<span class="string">&quot;I&#x27;m attacking with a Ak!!&quot;</span>);<span class="comment">//awesome!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAttackPower</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.decorted.getAttackPower()+<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🔼就像上面的简单例子，一个包装类把基本类<code>warped</code>起来，形成了一个新的类，新的类不仅添加了新的动作，还保留了基本类的动作。</p><p>优点：</p><p>👍 装饰模式与继承关系的目的都是要拓展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者“除掉”一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</p><p>👍 通过不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出更多不同行为的组合。</p><p>缺点：</p><p>👎种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p><p>装饰器语法最常见的应用就是我们熟悉的<code>java</code>里面的<code>AOP</code>(面向切面)编程，在不影响原有功能的情况下，增加新的处理逻辑，比如添加各种<code>filter</code>,这些<code>filter</code>就像洋葱一样层层包裹，最终执行原有的逻辑，但是在之前和之后，都可以随意添加新的行为，因此，特别适合安全检查，缓存，调试，日志记录等等行为。</p><h3 id="装饰器语法"><a class="header-anchor" href="#装饰器语法">¶</a>装饰器语法</h3><p>第一次看到装饰器语法是在使用<code>python</code>的时候，现在<code>es7</code>也实现了装饰器语法。</p><p>首次看到装饰器语法，用过<code>java</code>注解的也许会混到一起，其实这两个东西除了长得像外，原理完全不一样。</p><blockquote><p>Python decorators were inspired in part by Java annotations, and have a similar syntax</p><p>​                                                                                                                      --wikipedia</p></blockquote><p>根据<code>wikipedia</code>的说法，装饰器语法的灵感来源于<code>java</code>的注解，所以他们有类似的语法。</p><p>注解是利用反射，它本身不改变被注解对象的行为和性质，只有理解这些注解的处理器才会改变行为，在运行的时候起作用。</p><p>装饰器实际上是语法糖，利于了<code>python</code>,<code>javascript</code>函数可以赋值，传参的特性，函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，对嵌套函数做了简化。</p><p>😋引申：如果想了解更多关于<code>javascript</code>函数式特性的知识，可以看下面⬇️</p><p>[<a href="https://www.bookstack.cn/books/mostly-adequate-guide-chinese">JS 函数式编程指南中文版</a> ](<a href="https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md">https://www.bookstack.cn/read/mostly-adequate-guide-chinese/README.md</a>)</p><p>相信看完，你会对<code>javascript</code>有新的认识。</p><p>下面重头戏来了，到底在<code>javascript</code>里，怎么实现自己的装饰器呢？</p><p>关键的<code>api</code>是<code>Object.defineProperty</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p>参数：</p><p><strong>obj</strong> 要在其上定义属性的对象</p><p><strong>prop</strong> 要定义或修改的属性的名称。</p><p><strong>descriptor</strong> 将被定义或修改的属性描述符。</p><p>装饰器可以用到<code>类</code>，属性和类的<code>方法</code>上，不能用于<code>function</code>❔<a href="http://es6.ruanyifeng.com/#docs/decorator#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%AE%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%EF%BC%9F">为什么修饰器不能用于函数？</a></p><p>👍想详细了解装饰器语法，可以去看阮一峰老师的<code>es6</code>教程</p><p><a href="http://es6.ruanyifeng.com/#docs/decorator">修饰器</a></p><p>下篇博文，我会用实例代码实现不同的装饰器（等我看完上面的教程先😄)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance--一个用来获取页面性能的接口</title>
      <link href="/posts/94e1353c/"/>
      <url>/posts/94e1353c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近被问到一个问题，如何判断页面加载时间，我第一时间想到的是打开<code>devtool</code>看下<code>Network</code>下面</p><p><code>DOMContentLoaded</code>和<code>load</code>分别用了多久，如果自己写的话，要用到<code>window.onload</code>函数，但是实际上，web已经给出了<code>api</code>，获取页面性能，并且大部分现代浏览器也支持这个<code>api</code>.</p></blockquote><h3 id="Performance简介"><a class="header-anchor" href="#Performance简介">¶</a><strong>Performance</strong>简介</h3><p>根据<code>mdn</code>里面的说法:</p><blockquote><p><strong>Performance</strong> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API">Resource Timing API</a>。</p></blockquote><p>并且，这些数据是只读的。</p><p><code>preformance</code>对象有三个标准属性，和一个<code>chrome</code>添加的非标准库–<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory"><code>performance.memory</code></a>，用来获取到基本内存的使用情况，一般来说不要用这个非标准的<code>api</code>。</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/navigation"><code>Performance.navigation</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceNavigation"><code>PerformanceNavigation</code></a> 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等。Not available in workers.</p><p>👎<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timing"><code>Performance.timing</code></a> [只读]</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming"><code>PerformanceTiming</code></a> 对象包含延迟相关的性能信息。Not available in workers.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/memory"><code>performance.memory</code></a></p><p>其是 Chrome 添加的一个非标准扩展，这个属性提供了一个可以获取到基本内存使用情况的对象。<strong>不应该</strong>使用这个非标准的 API。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/timeOrigin"><code>Performance.timeOrigin</code></a> [只读]</p><p>返回性能测量开始时的时间的高精度时间戳。</p><p>关于更精确的资料请查看<code>mdn</code>官方文档。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance">Performance</a></p><h3 id="如何根据Performance-timing获取加载时间"><a class="header-anchor" href="#如何根据Performance-timing获取加载时间">¶</a>如何根据<code>Performance.timing</code>获取加载时间</h3><p>在此之前，读者需要明白一点浏览器工作的基本流程和原理，比如经常在面试时被问到的“从url输入到页面加载经过了什么流程？”</p><p>这里有几篇非常详细的文章（最起码是我遇到的最详细的，如果你看到过更详细的，或者还有其他补充，请在下方留言，万分感谢😙 ），介绍了这个流程。</p><p><a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p>也就是说，你最起码要知道<code>dns</code>解析，<code>http</code>请求，页面渲染等认识。</p><p><code>timing</code>就是从输入<code>url</code>到页面展示的全过程的时间统计，单位是毫秒，只读。</p><p>➕ 属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart"><code>PerformanceTiming.navigationStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和PerformanceTiming.fetchStart相同。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventStart"><code>PerformanceTiming.unloadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/unloadEventEnd"><code>PerformanceTiming.unloadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了<code>unload</code>事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectStart"><code>PerformanceTiming.redirectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/redirectEnd"><code>PerformanceTiming.redirectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/fetchStart"><code>PerformanceTiming.fetchStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupStart"><code>PerformanceTiming.domainLookupStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domainLookupEnd"><code>PerformanceTiming.domainLookupEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，表征了域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 <code>PerformanceTiming.fetchStart一致。</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectStart"><code>PerformanceTiming.connectStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/connectEnd"><code>PerformanceTiming.connectEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/secureConnectionStart"><code>PerformanceTiming.secureConnectionStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/requestStart"><code>PerformanceTiming.requestStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseStart"><code>PerformanceTiming.responseStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/responseEnd"><code>PerformanceTiming.responseEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domLoading"><code>PerformanceTiming.domLoading</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构开始解析时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState"><code>Document.readyState</code></a>属性变为“loading”、相应的 <code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domInteractive"><code>PerformanceTiming.domInteractive</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前网页DOM结构结束解析、开始加载内嵌资源时（即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState"><code>Document.readyState</code></a>属性变为“interactive”、相应的<code>readystatechange</code>事件触发时）的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventStart"><code>PerformanceTiming.domContentLoadedEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当解析器发送<code>DOMContentLoaded</code> 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domContentLoadedEventEnd"><code>PerformanceTiming.domContentLoadedEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/domComplete"><code>PerformanceTiming.domComplete</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当前文档解析完成，即<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState"><code>Document.readyState</code></a> 变为 <code>'complete'且相对应的``readystatechange</code> 被触发时的Unix毫秒时间戳。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventStart"><code>PerformanceTiming.loadEventStart</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回该文档下，<code>load</code>事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/loadEventEnd"><code>PerformanceTiming.loadEventEnd</code></a> 只读</p><p>是一个无符号long long 型的毫秒数，返回当<code>load</code>事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.</p><p>🔼 以上属性来自<code>mdn</code>文档。</p><p>根据上面的定义，可以得出下面的常用的时间计算公式：</p><p><strong>常用计算：</strong><br><code>DNS</code>查询耗时 ：<code>domainLookupEnd</code> - <code>domainLookupStart</code><br><code>TCP</code>链接耗时 ：<code>connectEnd</code> -<code> connectStart</code><br><code>request</code>请求耗时 ：<code>responseEnd</code> - <code>responseStart</code><br>解析<code>dom</code>树耗时 ： <code>domComplete</code> - <code>domInteractive</code><br>白屏时间 ：<code>responseStart</code> -<code> navigationStart</code><br><code>domready</code>时间(用户可操作时间节点) ：<code>domContentLoadedEventEnd</code> -<code> navigationStart</code><br><code>onload</code>时间(总下载时间) ：<code>loadEventEnd</code> - <code>navigationStart</code></p><h4 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h4><p>[<a href="https://www.cnblogs.com/bldxh/p/6857324.html">Performance — 前端性能监控利器</a>](<a href="https://www.cnblogs.com/bldxh/p/6857324.html">https://www.cnblogs.com/bldxh/p/6857324.html</a>)</p><p><a href="https://w3c.github.io/navigation-timing/#introduction">w3c文档(<a href="https://w3c.github.io/navigation-timing/#introduction">https://w3c.github.io/navigation-timing/#introduction</a>)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">mdn文档(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming</a>)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加法模拟器</title>
      <link href="/posts/909f226/"/>
      <url>/posts/909f226/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不用 “+” 怎么实现加法呢？相信大家看到第一时间就会想到用位运算，特别是计算机基础好的同学，立马想到计算机本质不就是2进制做位运算实现计算的吗？</p></blockquote><h3 id="先复习下位运算"><a class="header-anchor" href="#先复习下位运算">¶</a>先复习下位运算</h3><p>与运算<code>&amp;</code><br><code>2&amp;3</code><br>2的2进制是<code>10</code><br>3的2进制是<code>11</code><br>所以就是<code>10</code>和<code>11</code>做与运算,只有双方都是<code>true</code>的时候，结果才为<code>true</code>。</p><p>注意：如果是负数，需要计算补码来做位运算，正数的补码和本身相等。比如<code>-1</code></p><p>源码 1000 0001</p><p>反码 1111 1110</p><p>补码 1111 1111</p><table><thead><tr><th>与运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>false</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></tbody></table><table><thead><tr><th>或运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr></tbody></table><table><thead><tr><th>异或运算</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td></tr></tbody></table><h3 id="异或和与运算"><a class="header-anchor" href="#异或和与运算">¶</a>异或和与运算</h3><p>异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>   <span class="comment"># 1010</span></span><br><span class="line">b = <span class="number">5</span>    <span class="comment"># 0101</span></span><br><span class="line">a^b = <span class="number">15</span> <span class="comment"># 1111</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">10</span>    <span class="comment">#1010</span></span><br><span class="line">d = <span class="number">6</span>     <span class="comment">#0110</span></span><br><span class="line">c^b = <span class="number">12</span>  <span class="comment">#1100</span></span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>  <span class="comment"># 1010</span></span><br><span class="line">b = <span class="number">5</span>   <span class="comment"># 0101</span></span><br><span class="line">a&amp;b = <span class="number">0</span> <span class="comment"># 0000</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">10</span>   <span class="comment">#1010</span></span><br><span class="line">d = <span class="number">6</span>    <span class="comment">#0110</span></span><br><span class="line">c&amp;b = <span class="number">2</span>  <span class="comment">#0010</span></span><br></pre></td></tr></table></figure><p>看出点眉目没有？<br>异或，得到的是两个数没进位的和；而与。得到的是需要进位的位置（这里的位置并不是一一对应，需要向左移动一位，）</p><p>算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        res = a^b</span><br><span class="line">        b = (a&amp;b)&lt;&lt;<span class="number">1</span></span><br><span class="line">        a = res</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">bin</span>(a)[<span class="number">2</span>:],<span class="built_in">bin</span>(b)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> a  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 10 加 6    </span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"> <span class="number">1100</span>     <span class="number">100</span></span><br><span class="line"> <span class="number">1000</span>    <span class="number">1000</span></span><br><span class="line">    <span class="number">0</span>   <span class="number">10000</span></span><br><span class="line"><span class="number">10000</span>       <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>原理<br>a，b先用异或获取不进位的结果，在用与运算获取进位，这个称为进位补偿，然后把这两个结果相加就是a+b了，<br>但是不然用加法啊，怎么办呢？ 可以把前面的流程再走一次，直到进位补偿为0，这时候，上个异或结果就是最终相加的结果了。</p><p>根据上面的原理<br>1.a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)<br>2.无进位加法使用异或运算计算得出<br>3.进位结果使用与运算和移位运算计算得出<br>4.循环此过程，直到进位为 0</p><p>用一个公式就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b = a^b + (a&amp;b)&lt;&lt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>不过其实还有更简单的方法,毕竟<br><strong>人生苦短，我选python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([a, b])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout和setInterval的区别</title>
      <link href="/posts/64e435bc/"/>
      <url>/posts/64e435bc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们再前端开发中需要实现定时任务或者<code>js</code>动画，都要用到<code>setTimeout</code>和<code>setInterval</code>z这两个函数，但是对于他们的原理，如果不清楚，往往会造成一些意想不到的问题。</p></blockquote><h3 id="setTimeout"><a class="header-anchor" href="#setTimeout">¶</a><code>setTimeout</code></h3><p><code>setTimeout</code>方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>[,delay,param1...])</span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>[,delay])</span><br><span class="line"><span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(code[,delay])</span><br></pre></td></tr></table></figure><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p><code>function</code></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function"><code>function</code></a> 是你想要在到期时间(<code>delay</code>毫秒)之后执行的<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function">函数</a>。</p><p><code>code</code></p><p>这是一个可选语法，你可以使用字符串而不是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function"><code>function</code></a> ，在<code>delay</code>毫秒之后编译和执行字符串 (使用该语法是<strong>不推荐的,</strong> 原因和使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a>一样，有安全风险)。</p><p><code>delay </code>可选</p><p>延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0，意味着“马上”执行，或者尽快执行。不管是哪种情况，实际的延迟时间可能会比期待的(delay毫秒数) 值长，原因请查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout#Reasons_for_delays_longer_than_specified">Reasons for delays longer than specified</a>。</p><p><code>param1, ..., paramN</code> 可选</p><p>附加参数，一旦定时器到期，它们会作为参数传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/function"><code>function</code></a></p><h4 id="返回值"><a class="header-anchor" href="#返回值">¶</a>返回值</h4><p>返回值<code>timeoutID</code>是一个正整数，表示定时器的编号。这个值可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout"><code>clearTimeout()</code></a>来取消该定时器。</p><h4 id="用途"><a class="header-anchor" href="#用途">¶</a>用途</h4><p>举个例子，三秒后跳转新页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    location.<span class="property">href</span> = <span class="string">&quot;url&quot;</span></span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>在函数执行前取消</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    key = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>) &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myStopFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只是掌握了上面的用法，不了解它的原理，就会犯一些错误</p><p>比如一个常见的面试题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1;i &lt;= 5;i ++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">  &#125;,i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问打印出来的是什么？</p><p>如果对闭包和作用域不了解的同学会以为是每隔一秒就输出1,2,3,4,5。但实际上是每隔一秒输出了6。</p><p>原因就是作用域，在<code>javascript</code>里面没有块作用域，因此，当<code>setTimeout</code>里面的函数执行的时候，所有的i都是<code>for</code>循环里面的<code>i</code>，此时，<code>i</code>是6。</p><p>另外，说到<code>setTimeout</code>就一定要说一下事件循环，这个概念比较复杂，下面简单说一下，</p><p><code>setTimeout</code>运行后，会把第一个参数的函数在第二个参数设置的时间之后，将其放入异步队列里面，然后等到主线程函数栈为空，在执行这个函数。</p><p>这里有个需要注意的地方，</p><blockquote><p>HTML5 标准规定了<code>setTimeout()</code>的第二个参数的最小值，即最短间隔，不得低于4毫秒。如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。</p></blockquote><p>这意味着，即使你把第二个参数设置为0，也要最少等个4ms才能进入异步队列。另外，就算进入异步队列,也要等队列里面其他未执行的函数执行完，因此，可不要以为只要设置一个时间，就一定可以准时执行这个函数。</p><p>那么，怎么让上面的代码打印出0,1,2,3,4,5呢？</p><p>可以用下面的方法。</p><p>1.<code>es6</code>的<code>let</code>关键词</p><p><code>let</code>是<code>es6</code>的块作用域的声明关键词。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.利用闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i ++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.利用第三个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);    </span><br><span class="line">   &#125;, i*<span class="number">1000</span>,i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips:</p><p><code>setTimeout</code>第一个参数函数里面的<code>this</code>是<code>window</code>。</p><p>###　setInterval</p><p><strong>setInterval()</strong> 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intervalID = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(func, delay[, param1, param2, ...]);</span><br><span class="line"><span class="keyword">let</span> intervalID = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(code, delay);</span><br></pre></td></tr></table></figure><p>参数</p><ul><li><code>intervalID</code> 是此重复操作的唯一辨识符，可以作为参数传给<code>clearInterval``()</code>。</li><li><code>func</code> 是你想要重复调用的函数。</li><li><code>code</code> 是另一种语法的应用，是指你想要重复执行的一段字符串构成的代码(使用该语法是<strong>不推荐</strong>的，不推荐的原因和<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval#Don't_use_eval!">eval()</a>一样)。</li><li><code>delay</code> 是每次延迟的毫秒数 (一秒等于1000毫秒)，函数的每次调用会在该延迟之后发生。和<a href="https://developer.mozilla.org/en-US/docs/DOM/window.setTimeout#Minimum_delay_and_timeout_nesting">setTimeout</a>一样，实际的延迟时间可能会稍长一点。</li></ul><p>返回值</p><p>返回一个 intervalID。可以用clearInterval函数来取消定时任务。</p><p><strong>这里需要注意，于setTimeout返回的id公用一个id池</strong></p><p>通常，这个函数用来执行周期执行的函数，比如动画之类的效果。</p><p>mdn里面有个打字机效果的例子。</p><p><a href="https://mdn.mozillademos.org/files/3997/typewriter.html">打字机效果</a></p><p>和<code>setTimeout</code>一样，也是加入到异步队列里，等待合适的时机运行。</p><blockquote><p>当使用<code>setInterval</code>时,仅当(在队列中)没有该定时器的任何其他代码实例时,才将定时器代码添加到队列中,引用JavaScript高级程序设计第三版书中语句</p></blockquote><p>(即：当前一个定时器代码执行时,紧跟后面的第一个定时器代码将添加到队列中,等待执行,再后面的定时器代码不会添加到队列中)</p><p>所以，如果你的函数（第一个参数）执行时间比较长，但是你的执行间隔时间设置的比较短，可不要以为可以精准的在预料的时间点会执行设置的函数。</p><p>此外，第二个参数也有一个最短的默认参数，在<code>chrome</code>里面是7ms。</p><p>当定时器代码执行时间超过指定间隔,那么某些定时器代码就会被跳过(即后面的定时器代码不会被添加到队列中),前一个定时器代码执行完毕后,队列中的定时器代码立刻执行,各定时器之间的代码执行没有间隔。这时，需要使用链式<code>setTimeout</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    //要执行的代码 </span><br><span class="line">    setTimeout(arguments.callee,2000);                   </span><br><span class="line">&#125;,2000);</span><br></pre></td></tr></table></figure><p>上面的代码就是用<code>setTimeout</code>来模拟<code>setInterval</code>,如果面试官问你怎么用<code>setTimeout</code>来解决定时器问题，可以用上面的代码来回答哦。</p><p>如果要求在每隔一个固定的时间间隔后就精确地执行某动作，那么最好使用<code>setInterval</code>，</p><p>比如函数执行的时间比较短的，用来实现动画效果。</p><p>如果每次函数的调用需要繁重的计算以及很长的处理时间，而且不希望他们之间互相干扰，那么最好使用<code>setTimeout</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="/posts/9ba82001/"/>
      <url>/posts/9ba82001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>快乐就完事了。</p></blockquote><h3 id="快乐数是什么"><a class="header-anchor" href="#快乐数是什么">¶</a>快乐数是什么</h3><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">19</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: </span><br><span class="line"><span class="number">1</span>^<span class="number">2</span> + <span class="number">9</span>^<span class="number">2</span> = <span class="number">82</span></span><br><span class="line"><span class="number">8</span>^<span class="number">2</span> + <span class="number">2</span>^<span class="number">2</span> = <span class="number">68</span></span><br><span class="line"><span class="number">6</span>^<span class="number">2</span> + <span class="number">8</span>^<span class="number">2</span> = <span class="number">100</span></span><br><span class="line"><span class="number">1</span>^<span class="number">2</span> + <span class="number">0</span>^<span class="number">2</span> + <span class="number">0</span>^<span class="number">2</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="编写一个算法来判断一个数是不是“快乐数”。"><a class="header-anchor" href="#编写一个算法来判断一个数是不是“快乐数”。">¶</a>编写一个算法来判断一个数是不是“快乐数”。</h3><p>思路，不断的求输入数字每个位置平方和，然后看是否等于1，等于1就是快乐数，问题是，什么时候判断false。<br>答案就是出现无线循环的时候，也就是出现重复的数字，必定会进行下一次循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        already = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">            nums = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                temp = n % <span class="number">10</span></span><br><span class="line">                nums = nums + temp * temp</span><br><span class="line">                n = n // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> nums <span class="keyword">in</span> already:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                already.add(nums)</span><br><span class="line">                n = nums</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的循环遍历方法</title>
      <link href="/posts/8925371c/"/>
      <url>/posts/8925371c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近稍微刷了一下<code>leetcode</code>，想巩固一下编程功底，但是发现工作后的很少用到在学校时用的数据结构，好多都忘了，在这里做下记录。</p></blockquote><h3 id="1-二叉树的前序，中序，后序遍历"><a class="header-anchor" href="#1-二叉树的前序，中序，后序遍历">¶</a>1.二叉树的前序，中序，后序遍历</h3><p>前序遍历方向是 中 左 右</p><p>中序遍历方向是 左 中 右</p><p>后序遍历方向是 右 左 中</p><p>根据上面的定义，看的出来对于左右节点，顺序是不变的，只是中间节点出现的位置改变。所以，这也是一个防止忘记的技巧。</p><h3 id="2-代码实现"><a class="header-anchor" href="#2-代码实现">¶</a>2.代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义节点对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备测试数据</span></span><br><span class="line">a = TreeNode(<span class="number">1</span>)</span><br><span class="line">a.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">a.left.left = TreeNode(<span class="number">4</span>)</span><br><span class="line">a.left.right = TreeNode(<span class="number">5</span>)</span><br><span class="line">a.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">a.right.left = TreeNode(<span class="number">6</span>)</span><br><span class="line">a.right.right = TreeNode(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归实现中序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inerderTraversalLoop</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环实现中序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr=curr.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = stack.pop()</span><br><span class="line">                result.append(curr.val)</span><br><span class="line">                curr = curr.right</span><br><span class="line">        <span class="keyword">return</span> result        </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predorderTraversal</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归实现前序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.predorderTraversal(root.left) + self.predorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predorderTraversalLoop</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环实现前序遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> curr:</span><br><span class="line">                result.append(curr.val)</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">                curr = curr.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = stack.pop()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result         </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归实现后续遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversalLoop</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环实现后续遍历</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> curr:</span><br><span class="line">               result.append(curr.val)</span><br><span class="line">               stack.append(curr.left)</span><br><span class="line">               curr = curr.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               curr = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]     </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    <span class="built_in">print</span>(s.inorderTraversal(a))</span><br><span class="line">    <span class="built_in">print</span>(s.inerderTraversalLoop(a))</span><br><span class="line">    <span class="built_in">print</span>(s.predorderTraversal(a))</span><br><span class="line">    <span class="built_in">print</span>(s.predorderTraversalLoop(a))</span><br><span class="line">    <span class="built_in">print</span>(s.postorderTraversal(a))</span><br><span class="line">    <span class="built_in">print</span>(s.postorderTraversalLoop(a))</span><br><span class="line"><span class="comment"># [4, 2, 5, 1, 6, 3, 7]</span></span><br><span class="line"><span class="comment"># [4, 2, 5, 1, 6, 3, 7]</span></span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 3, 6, 7]</span></span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 3, 6, 7]</span></span><br><span class="line"><span class="comment"># [4, 5, 2, 6, 7, 3, 1]</span></span><br><span class="line"><span class="comment"># [4, 5, 2, 6, 7, 3, 1]   </span></span><br></pre></td></tr></table></figure><p>上面就是实现代码。</p><p>先说下递归实现，根据第一节的遍历顺序定义，这里很简单就可以写出递归程序，只是返回的时候，更改下中间节点的位置就好。</p><p>在说下循环实现，在<code>LeetCode</code>里面，循环都是<code>hard</code>和<code>middle</code>的题，可见，用循环实现起来并不容易。</p><p>主要是要在一个函数里面实现遍历到整个树形结构，如果你能想到用<strong>栈</strong>（<code>stack</code>）来存节点，那么你应该差不多对数据结构运用有一定经验了。</p><p>如下的二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">1</span></span><br><span class="line">   <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>    <span class="number">5</span></span><br></pre></td></tr></table></figure><p>对于中序遍历</p><p>每次将当前结点<code>curr</code>的左子结点push到栈中，直到当前结点<code>curr</code>为None。这时，<code>pop</code>出栈顶的第一个元素，设其为当前结点，并输出该结点的<code>val</code>值，且开始遍历该结点的右子树。当<code>stack</code>和<code>curr</code>都为空的时候，结束循环。</p><p>对于前序遍历</p><p>输出当前结点<code>curr</code>的<code>val</code>，并将右子结点<code>push</code>到栈中，然后将左子结点设为当前结点。入栈和出栈条件（当前结点<code>curr</code>不为<code>None</code>时，每一次循环将当前结点<code>curr</code>入栈；当前结点<code>curr</code>为<code>None</code>时，则出栈一个结点）以及循环结束条件（整个循环在<code>stack</code>和<code>curr</code>皆为<code>None</code>的时候结束）与中序遍历一模一样。</p><p>对于后序遍历</p><p>后序遍历在<code>leetcode</code>上是<code>hard</code>难度的题，这里有个技巧，后序是左右中，我们按照中右左的方式遍历，然后反向输出就可以了。而且中右左不就是前序遍历左右互相换下吗？</p><h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3><p>二叉树的循环遍历，还是要借助于栈这个非常有用的数据结构，有时我们都明白，比如，栈啊，队列啊，这些结构有什么特性，但是，要真正灵活的使用这些数据结构，还需要多多练习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅模式的javascript实现</title>
      <link href="/posts/4ec38d83/"/>
      <url>/posts/4ec38d83/</url>
      
        <content type="html"><![CDATA[<h3 id="发布订阅模式"><a class="header-anchor" href="#发布订阅模式">¶</a>发布订阅模式</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构</a>中，<strong>发布-订阅</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF">消息</a><a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BC%8F">范式</a>，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p><p>发布/订阅是<a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>范式的兄弟，通常是更大的<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6&amp;action=edit&amp;redlink=1">面向消息中间件</a>系统的一部分。大多数消息系统在<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">API</a>中同时支持消息队列模型和发布/订阅模型，例如<a href="https://zh.wikipedia.org/wiki/Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1">Java消息服务</a>（JMS）。</p><p>这种模式提供了更大的网络<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">可扩展性</a>和更动态的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91">网络拓扑</a>，同时也降低了对发布者和发布数据的结构修改的灵活性。</p><p>优点：</p><ol><li>松耦合：发布者与订阅者<a href="https://zh.wikipedia.org/wiki/%E6%9D%BE%E8%80%A6%E5%90%88">松耦合</a>，甚至不需要知道它们的存在。</li><li>可扩展性：通过并行操作，消息缓存，基于树或基于网络的路由等技术，发布/订阅提供了比传统的客户端–服务器更好的<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E6%94%BE%E6%80%A7">可扩展性</a>。</li></ol><h3 id="JavaScript里的发布订阅模式"><a class="header-anchor" href="#JavaScript里的发布订阅模式">¶</a><code>JavaScript</code>里的发布订阅模式</h3><p>在<code>dom</code>事件里面，有一种事件监听的模式就是基于发布订阅设计的，比如非常常见的给节点添加点击事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button&quot;</span>)</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">() =&gt;</span> &#123;<span class="title function_">alert</span>(<span class="string">&#x27;click&#x27;</span>)&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这样的写法好处很明显，分离事件触发和事件内容解耦。</p><p>在<code>node</code>里面，还有<code>EventEmitter</code>这个类，用来实现发布订阅模式，来处理不同对象之间的事件调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyEventEmitter</span> <span class="keyword">extends</span> <span class="title class_">EventEmitter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEventEmitter = <span class="keyword">new</span> <span class="title class_">MyEventEmitter</span></span><br><span class="line">myEventEmitter.<span class="title function_">on</span>(<span class="string">&#x27;event&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;target this event&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">myEventEmitter.<span class="title function_">emit</span>(<span class="string">&quot;event&quot;</span>)</span><br><span class="line"><span class="comment">// target this event</span></span><br></pre></td></tr></table></figure><p>我之前用<code>BackBone</code>构建单页面应用的时候，就广泛用到了发布订阅模式处理不同组件之间的数据交互，但是这种方法如果滥用，会造成事件交互逻辑的不清晰，所以，父子组件数据交互还是推荐用回调的方式来做。</p><h3 id="怎么实现eventEmitter"><a class="header-anchor" href="#怎么实现eventEmitter">¶</a>怎么实现<code>eventEmitter</code></h3><p>下面是简单实现<code>eventEmitter</code>的<code>javaScript</code>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">EventEmitter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_event</span> = &#123;&#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxListenerNum</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">on</span> = <span class="keyword">function</span>(<span class="params">type,callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> callback !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;callback must be a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">_event</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_event</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>) <span class="comment">// 这里判断不存在就生成一个，如果是继承的，不会继承这个 _event</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_event</span>[type] ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_event</span>[type.<span class="property">length</span> &gt; <span class="variable language_">this</span>.<span class="property">maxListenerNum</span>] ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;too long&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_event</span>[type].<span class="title function_">push</span>(callback)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_event</span>[type] = [callback]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">once</span> = <span class="keyword">function</span> (<span class="params">type,callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">warp</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">callback</span>(...args)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeListener</span>(type,warp)</span><br><span class="line">    &#125;</span><br><span class="line">    warp.<span class="property">flag</span> = callback</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type,warp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeListener</span> = <span class="keyword">function</span>(<span class="params">type,callback</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_event</span>[type] ) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_event</span>[type].<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="property">_event</span>[type].<span class="title function_">indexOf</span>(callback),<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeListeners</span> = <span class="keyword">function</span>(<span class="params">type</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_event</span>[type] = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span>(<span class="params">type,...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">_event</span>[type]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_event</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>(...args)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> <span class="title class_">EventEmitter</span></span><br><span class="line"></span><br><span class="line">my.<span class="title function_">on</span>(<span class="string">&#x27;a&#x27;</span>,<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my.<span class="title function_">once</span>(<span class="string">&#x27;once&#x27;</span>, <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">a,b</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a+b); </span><br><span class="line">&#125;</span><br><span class="line">my.<span class="title function_">on</span>(<span class="string">&#x27;b&#x27;</span>,add)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;once&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;once&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">my.<span class="title function_">removeListeners</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">my.<span class="title function_">removeListener</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">my.<span class="title function_">emit</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参考：</p><p>1.<a href="https://zh.wikipedia.org/zh-hans/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85">https://zh.wikipedia.org/zh-hans/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85</a></p><p>2.<a href="https://segmentfault.com/a/1190000015762318">https://segmentfault.com/a/1190000015762318</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞懂ajax</title>
      <link href="/posts/e9a05528/"/>
      <url>/posts/e9a05528/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每个会用<code>jquery</code>的人都会用<code>$.ajax</code>发起一个<code>ajax</code>请求，然后再回调函数里面取得返回的数据，但是并不是所有的人都知道这个流程里面发生了什么事，本文就深入讨论下关于<code>ajax</code>的所有（大部分）细节。</p></blockquote><p>[TOC]</p><h3 id="1-Ajax其实是标准"><a class="header-anchor" href="#1-Ajax其实是标准">¶</a>1.Ajax其实是标准</h3><p>很多人误以为<code>XMLHttpRequest</code>就是<code>Ajax</code>，其实不然，他们两个是两个不同维度的概念。</p><p>搜索<code>ajax</code>的<code>wiki</code>，是这样介绍的：</p><blockquote><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML">XML</a>技术），指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>开发技术。Ajax的概念由<a href="https://zh.wikipedia.org/wiki/%E5%82%91%E8%A5%BF%C2%B7%E8%A9%B9%E5%A7%86%E5%A3%AB%C2%B7%E8%B3%88%E7%91%9E%E7%89%B9">杰西·詹姆士·贾瑞特</a>所提出。</p></blockquote><h4 id="ajax技术发展史"><a class="header-anchor" href="#ajax技术发展史">¶</a>ajax技术发展史</h4><p>​        上个世纪90年代，几乎所有的网站都由HTML页面实现，服务器处理每一个用户请求都需要重新加载网页。这样的处理方式效率不高。用户的体验是所有页面都会消失，再重新加载，即使只是一部分页面元素改变也要重新加载整个页面，不仅要刷新改变的部分，连没有变化的部分也要刷新。这会加重服务器的负担。</p><p>​        这可以用<a href="https://zh.wikipedia.org/wiki/%E7%95%B0%E6%AD%A5">异步</a>加载来解决。1995年，JAVA语言的第一版发布，随之发布的的Java applets（JAVA小程序）首次实现了异步加载。浏览器通过运行嵌入网页中的Java applets与服务器交换数据，不必刷新网页。1996年，Internet Explorer将iframe元素加入到HTML，支持局部刷新网页。</p><p>​        1998年前后，Outlook Web Access小组写成了允许<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%84%9A%E6%9C%AC&amp;action=edit&amp;redlink=1">客户端脚本</a>发送HTTP请求（<a href="https://zh.wikipedia.org/wiki/XMLHTTP">XMLHTTP</a>）的第一个组件。该组件原属于微软Exchange Server，并且迅速地成为了Internet Explorer 4.0[<a href="https://zh.wikipedia.org/wiki/AJAX#cite_note-2">2]</a>的一部分。部分观察家认为，Outlook Web Access是第一个应用了Ajax技术的成功的商业应用程序，并成为包括Oddpost的网络邮件产品在内的许多产品的领头羊。但是，2005年初，许多事件使得Ajax被大众所接受。<a href="https://zh.wikipedia.org/wiki/Google">Google</a>在它著名的交互应用程序中使用了异步通讯，如<a href="https://zh.wikipedia.org/w/index.php?title=Google%E8%AE%A8%E8%AE%BA%E7%BB%84&amp;action=edit&amp;redlink=1">Google讨论组</a>、<a href="https://zh.wikipedia.org/wiki/Google%E5%9C%B0%E5%9B%BE">Google地图</a>、<a href="https://zh.wikipedia.org/w/index.php?title=Google%E6%90%9C%E7%B4%A2%E5%BB%BA%E8%AE%AE&amp;action=edit&amp;redlink=1">Google搜索建议</a>、<a href="https://zh.wikipedia.org/wiki/Gmail">Gmail</a>等。Ajax这个词由《<em>Ajax: A New Approach to Web Applications</em>》一文所创，该文的迅速流传提高了人们使用该项技术的意识。另外，对Mozilla/Gecko的支持使得该技术走向成熟，变得更为简单易用。</p><p>​        所以<code>ajax</code>是一种技术方案，<code>XMLHttpRequest</code>是<code>ajax</code>在web端实现所依赖的一个对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应，来异步的操作网页。</p><p>​        只是现在，市面上基本都用<code>XMLHttpRequest</code> 来发送<code>ajax</code>请求。</p><p>​        <code>es6</code>新增了<code>fetch</code>来代替<code>XMLHttpRequest</code> ,比起<code>XMLHttpRequest</code>具有更好的可扩展性和高效性，下文会详细介绍。</p><p>​</p><h3 id="2-XMLHttpRequest介绍"><a class="header-anchor" href="#2-XMLHttpRequest介绍">¶</a>2.<code>XMLHttpRequest</code>介绍</h3><blockquote><p>​       <strong>XMLHTTP</strong>是一组<a href="https://zh.wikipedia.org/wiki/API">API</a>函数集，可被<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>、JScript、<a href="https://zh.wikipedia.org/wiki/VBScript">VBScript</a>以及其它<a href="https://zh.wikipedia.org/wiki/Web%E6%B5%8F%E8%A7%88%E5%99%A8">web浏览器</a>内嵌的<a href="https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>调用，通过<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>在浏览器和<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8">web服务器</a>之间收发<a href="https://zh.wikipedia.org/wiki/XML">XML</a>或其它数据。XMLHTTP最大的好处在于可以动态地更新网页，它无需重新从服务器读取整个网页，也不需要安装额外的插件。该技术被许多网站使用，以实现快速响应的动态网页应用。例如：<a href="https://zh.wikipedia.org/wiki/Google">Google</a>的<a href="https://zh.wikipedia.org/wiki/Gmail">Gmail</a>服务、Google Suggest动态查找界面以及<a href="https://zh.wikipedia.org/wiki/Google%E5%9C%B0%E5%9B%BE">Google Map</a>地理信息服务。</p></blockquote><p>​        一开始，巨硬公司发明了这个可以用来构造无刷新页面的对象，这个对象可以通过<code>javascript</code>,<code>VBScript</code>或者其他的浏览器内置脚本访问，后来其他的浏览器开发公司也逐步实现了这个标准对象，到了<code>dom3</code>标准时代，它已经成为<a href="https://zh.wikipedia.org/wiki/W3C">W3C</a>推荐的方法。截止2011年，大多数浏览器已经支持。互联网程序迎来了无刷新的页面时代，诞生了一大批优秀的<code>web</code>应用。</p><p>​现代浏览器基本都支持<code>ajax</code>,但是他们的技术方案却分为两种：</p><p>​标准浏览器通过 <code>XMLHttpRequest</code> 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><p>​IE浏览器通过<code>XMLHttpRequest</code>或者<code>ActiveXObject</code>对象同样实现了ajax的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="title class_">ProgID</span>);</span><br><span class="line"><span class="comment">// progID可以是下面的值，对应不同的版本</span></span><br><span class="line"><span class="title class_">Microsoft</span>.<span class="property">XMLHTTP</span></span><br><span class="line"><span class="title class_">Microsoft</span>.<span class="property">XMLHTTP</span><span class="number">.1</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">ServerXMLHTTP</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">ServerXMLHTTP</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">ServerXMLHTTP</span><span class="number">.4</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">ServerXMLHTTP</span><span class="number">.5</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">ServerXMLHTTP</span><span class="number">.6</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">XMLHTTP</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">XMLHTTP</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">XMLHTTP</span><span class="number">.4</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">XMLHTTP</span><span class="number">.5</span><span class="number">.0</span></span><br><span class="line"><span class="title class_">Msxml2</span>.<span class="property">XMLHTTP</span><span class="number">.6</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>​r如何取得全平台兼容的<code>XMLHttpRequest</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getXHR</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">ActiveXObject</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Msxml2.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;您的浏览器暂不支持Ajax!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>HTML 5</code>的概念形成后，<code>W3C</code>开始考虑标准化这个接口。2008年2月，就提出了<a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/">XMLHttpRequest Level 2</a> 草案（之前是<code>Level 1</code>）。这个新版本提出了很多实用的功能，大大的加快了互联网革新。</p><p>​<em>这里对比<code>level 1</code> 和 <code>level 2</code> 的区别</em></p><table><thead><tr><th>特性</th><th>level 1</th><th>level 2</th></tr></thead><tbody><tr><td>文本数据传送</td><td>支持</td><td>支持</td></tr><tr><td>读取上传二进制</td><td>不支持</td><td>支持</td></tr><tr><td>进度信息</td><td>不支持</td><td>支持</td></tr><tr><td>同源限制</td><td>不支持跨域</td><td>可发送跨域请求</td></tr><tr><td>超时时间</td><td>不支持自己设置</td><td><code>xhr.timeout</code>设置超时时间</td></tr></tbody></table><p>​此外，为了方便表单处理，<code>html5</code>新加了个<code>FormData</code>对象，新的标准同样支持这个对象，用来模拟表单。</p><p>关于<code>level 1</code> 和 <code>level 2</code>的区别，可也参考<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">XMLHttpRequest Level 2 使用指南</a>，阮老师对每个新特性都写了代码实例。</p><p><code>XMLHttpRequest</code>对象：</p><p>属性：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/channel"><code>channel</code></a> 草案，不知道是啥<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozAnon"><code>mozAnon</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozBackgroundRequest"><code>mozBackgroundRequest</code></a>草案，布尔值，为True 时，本次请求不带cookies或者头部认证信息<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozResponseArrayBuffer"><code>mozResponseArrayBuffer</code></a> 草案<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/mozSystem"><code>mozSystem</code></a> 草案<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/multipart"><code>multipart</code></a> 草案<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/onreadystatechange"><code>onreadystatechange</code></a> 只要``readyState` 发生改变，就调用这个函数。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState"><code>readyState</code></a> 当前的状态，分别是0:UNSENT,1:OPENED,2:HEADERS_RECEIVED,3:LOADING,4:DONE。在ie里，状态名称不一样。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/response"><code>response</code></a>请求响应的正文<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseText"><code>responseText</code></a> 返回一个DOMString，它包含对文本的请求的响应。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType"><code>responseType</code></a> 返回数据的类型，具体见下文<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseURL"><code>responseURL</code></a> 返回响应的序列化URL或空字符串<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseXML"><code>responseXML</code></a> 返回一个包含请求检索的HTML或XML的<code>Document</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status"><code>status</code></a> 响应的数字状态码，采用标准HTTP 状态码<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/statusText"><code>statusText</code></a> 状态码对应的文本信息<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/timeout"><code>timeout</code></a> 超时时间<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload"><code>upload</code></a> 返回<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a> 对象，用来表示上传的进度<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials"><code>withCredentials</code></a> 点击查看详情，和跨域请求认证有关</p><p>方法：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort"><code>abort()</code></a>终止请求，<code>readyState</code>会变为0<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getAllResponseHeaders"><code>getAllResponseHeaders()</code></a>返回所有的响应头<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getResponseHeader"><code>getResponseHeader()</code></a>返回指定的响应头<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open"><code>open()</code></a>初始化一个请求。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/overrideMimeType"><code>overrideMimeType()</code></a><code>level 1</code>的方法，用responseType代替</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send"><code>send()</code></a>发送http请求<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/sendAsBinary"><code>sendAsBinary()</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader"><code>setRequestHeader()</code></a>设置http请求头</p><h3 id="3-使用XMLHttpRequest"><a class="header-anchor" href="#3-使用XMLHttpRequest">¶</a>3.使用<code>XMLHttpRequest</code></h3><p>下面是用 <code>XMLHttpRequest</code>发送<code>ajax</code>  <code>get</code> 请求的例子（用到了大部分<code>api</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// 新建一个XMLHttpRequest对象实例</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&quot;url&quot;</span>); <span class="comment">// 设置请求方法和地址 </span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;text&quot;</span>; <span class="comment">// 设置返回的数据类型</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">3000</span>; <span class="comment">// 设置超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时处理函数</span></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 请求错误处理函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求进度处理函数</span></span><br><span class="line">xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; </span><br><span class="line"> <span class="keyword">if</span> (e.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> completedPercent = e.<span class="property">loaded</span> / e.<span class="property">total</span>; <span class="comment">// 请求百分比</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对completedPercent 操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功接收到请求的函数</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> = <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(); <span class="comment">// 发送请求</span></span><br></pre></td></tr></table></figure><p>接下来，介绍一些常用的<code>api</code>：</p><p>更详细的可以看<code>mdn</code>的文档,里面有<code>XMLHttpRequest</code>对象所有的属性，方法。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest </a></p><h4 id="open"><a class="header-anchor" href="#open">¶</a>open()`</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">open</span>(method, url)</span><br><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">open</span>(method, url, <span class="keyword">async</span>)</span><br><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">open</span>(method, url, <span class="keyword">async</span>, user)</span><br><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">open</span>(method, url, <span class="keyword">async</span>, user, password)</span><br></pre></td></tr></table></figure><p><code>method</code> 就是需要使用的http方法，包括[GET],[POST],[PUT],[DELETE]等。</p><p><code>url</code>就是请求的地址<code>url</code>。</p><p><code>async</code> @可选 一个可选的布尔参数，默认为<code>true</code>，表示要不要异步执行操作。如果值为<code>false</code>，<code>send()</code>方法直到收到答复前不会返回。如果<code>true</code>，已完成事务的通知可供事件监听器使用。如果<code>multipart</code>属性为<code>true</code>则这个必须为<code>true</code>，否则将引发异常。</p><p><code>user</code>@ 可选 用户名用于认证用途；默认为<code>null</code>。</p><p><code>password</code> @可选 密码用于认证用途，默认为<code>null</code>。</p><h4 id="setRequestHeader"><a class="header-anchor" href="#setRequestHeader">¶</a><code>setRequestHeader()</code></h4><p>**<code>XMLHttpRequest.setRequestHeader()**</code> 是设置HTTP请求头部的方法。此方法必须在  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/open"><code>open()</code></a>方法和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send"><code>send()</code></a>   之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。</p><h4 id="send"><a class="header-anchor" href="#send">¶</a>send()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void send();</span><br><span class="line">void send(ArrayBuffer data);</span><br><span class="line">void send(ArrayBufferView data);</span><br><span class="line">void send(Blob data);</span><br><span class="line">void send(Document data);</span><br><span class="line">void send(DOMString? data);</span><br><span class="line">void send(FormData data);</span><br></pre></td></tr></table></figure><p>​方法用于发送 HTTP 请求。如果是异步请求（默认为异步请求），则此方法会在请求发送后立即返回；如果是同步请求，则此方法直到响应到达后才会返回。<code>XMLHttpRequest.send()</code> 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null，此时参数应该在<code>url</code>后面。</p><p>😏 自定义一些header属性进行跨域请求时，可能会遇到&quot;<strong>not allowed by Access-Control-Allow-Headers in preflight response</strong>&quot;，你可能需要在你的服务端设置&quot;Access-Control-Allow-Headers&quot;。</p><p>接下来从一个完整的http请求流程介绍使用</p><h4 id="设置request-header"><a class="header-anchor" href="#设置request-header">¶</a>设置request header</h4><p>发送一个<code>http</code>请求之前，有时候我们需要设置一些请求头部信息。</p><p>比如常用的<code>cookie</code>,<code>content-type</code>等。</p><p>我们可以用<code>setRequestHeader(DOMString header, DOMString value)</code>这个函数设置。</p><ul><li>header大小写不明显，<code>cookie</code>和<code>Cookie</code>是等价的。</li><li><code>Content-Type</code>可以发送的数据类型可以看上面send函数的参数类型。</li><li>设置header 必须在<code>open</code> 和<code>send</code>之间，否则会报错。</li><li>这个函数可以调用多次，在<code>send</code>之前会合并多个调用设置的值。</li></ul><p>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;content-type&#x27;</span>,<span class="string">&#x27;multipart/form-data&#x27;</span>)</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;cookie&#x27;</span>,<span class="string">&#x27;asdaadfasdfasdfa&#x27;</span>)</span><br><span class="line"><span class="comment">// 上面设置后会合并两个header</span></span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><h4 id="获取Response-Header"><a class="header-anchor" href="#获取Response-Header">¶</a>获取<code>Response Header</code></h4><p>获取<code>response header</code> 可以通过<code>getAllResponseHeaders()</code> 和<code>getResponseHeader(header)</code></p><p>从名字上可以看出来，一个是获取所有的header ，一个是获取指定的某个header 对应的值。</p><p><code>getResponseHeader(header)</code> 的参数不分大小写。</p><p>但是: 这里获取部分header 是有<strong>限制</strong>的，<strong>为了安全考虑</strong>，不管是不是同源都规定客户端无法获取<code>Set-Cookie</code>这个字段，在跨域的请求里，只能获取“<code>simple response header</code>”和“<code>Access-Control-Expose-Headers</code>”。</p><p>解释：</p><blockquote><p>&quot;<code>simple response header</code>&quot;包括的 header 字段有：<code>Cache-Control</code>,<code>Content-Language</code>,<code>Content-Type</code>,<code>Expires</code>,<code>Last-Modified</code>,<code>Pragma</code>;<br>“<code>Access-Control-Expose-Headers</code>”：首先得注意是&quot;<code>Access-Control-Expose-Headers</code>&quot;进行<strong>跨域请求</strong>时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p></blockquote><p>eg:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&#x27;Cache-Control&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="指定返回的数据类型"><a class="header-anchor" href="#指定返回的数据类型">¶</a>指定返回的数据类型</h4><p>用过<code>jquery</code>的<code>ajax</code>都知道里面有个属性<code>dataType</code>可以指定服务器返回的数据类型。</p><p>如果想通过<code>XMLHttpRequest</code>设置返回的数据类型，可以通过<code>xhr.responseType</code>属性来设置。<code>responseType</code>是<code>xhr level 2</code>新增的属性，用来指定<code>xhr.response</code>的数据类型，目前还存在些兼容性问题。</p><p><em>可以设置的值是：</em></p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left"><code>xhr.response</code> 数据类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&quot;&quot;</code></td><td style="text-align:left"><code>String</code>字符串</td><td style="text-align:left">默认值(在不设置<code>responseType</code>时)</td></tr><tr><td style="text-align:left"><code>&quot;text&quot;</code></td><td style="text-align:left"><code>String</code>字符串</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&quot;document&quot;</code></td><td style="text-align:left"><code>Document</code>对象</td><td style="text-align:left">希望返回 <code>XML</code> 格式数据时使用</td></tr><tr><td style="text-align:left"><code>&quot;json&quot;</code></td><td style="text-align:left"><code>javascript</code> 对象</td><td style="text-align:left">存在兼容性问题，IE10/IE11不支持</td></tr><tr><td style="text-align:left"><code>&quot;blob&quot;</code></td><td style="text-align:left"><code>Blob</code>对象</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>&quot;arrayBuffer&quot;</code></td><td style="text-align:left"><code>ArrayBuffer</code>对象</td><td style="text-align:left"></td></tr></tbody></table><p>eg.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;blob&#x27;</span></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里有三个可以获取返回值的属性，分别是 response，responseType responseXml </span></span><br><span class="line">        <span class="keyword">var</span> bloob = <span class="variable language_">this</span>.<span class="property">response</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><p>获取返回值：</p><ul><li><code>xhr.response</code><ul><li>默认值：空字符串<code>&quot;&quot;</code></li><li>当请求完成时，此属性才有正确的值</li><li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li></ul></li><li><code>xhr.responseText</code><ul><li>默认值为空字符串<code>&quot;&quot;</code></li><li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li><li>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</li></ul></li><li><code>xhr.responseXML</code><ul><li>默认值为 <code>null</code></li><li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</li><li>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</li></ul></li></ul><h4 id="追踪ajax-的当前状态"><a class="header-anchor" href="#追踪ajax-的当前状态">¶</a>追踪<code>ajax</code> 的当前状态</h4><p>上文已经说过了<code>XMLHttpRequest</code>有<code>readyState</code>状态，共有5种。</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>UNSENT</code></td><td>代理被创建，但尚未调用 open() 方法。</td></tr><tr><td><code>1</code></td><td><code>OPENED</code></td><td><code>open()</code> 方法已经被调用。</td></tr><tr><td><code>2</code></td><td><code>HEADERS_RECEIVED</code></td><td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td></tr><tr><td><code>3</code></td><td><code>LOADING</code></td><td>下载中； <code>responseText</code> 属性已经包含部分数据。</td></tr><tr><td><code>4</code></td><td><code>DONE</code></td><td>下载操作已完成。</td></tr></tbody></table><p>状态改变的时候，会触发<code>onreadystatechange</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(xhr.<span class="property">readyState</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="设置超时时间"><a class="header-anchor" href="#设置超时时间">¶</a>设置超时时间</h4><p><code>timeout</code> 属性  单位 毫秒</p><p>如何计算时间？</p><p>开始时间指的是 <code>send</code>方法调用的时候</p><p>结束时间是<code>loadend</code>事件触发</p><p>😏注意在同步的请求里面，这个值必须设置为0.否则会报错。</p><h4 id="同步请求"><a class="header-anchor" href="#同步请求">¶</a>同步请求</h4><p>不建议发送同步请求</p><p>一定要发送的话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">open</span>(method, url [, <span class="keyword">async</span> = <span class="literal">true</span> [, username = <span class="literal">null</span> [, password = <span class="literal">null</span>]]])</span><br><span class="line"><span class="comment">// async 设置为false</span></span><br></pre></td></tr></table></figure><h4 id="显示进度"><a class="header-anchor" href="#显示进度">¶</a>显示进度</h4><p>我们可以通过<code>onprogress</code>事件来实时显示进度，默认情况下这个事件每50ms触发一次。</p><p>但是，上传和下载，是不同对象的<code>onprogress</code>事件。</p><table><thead><tr><th>上传</th><th><code>xhr.upload</code></th></tr></thead><tbody><tr><td>下载</td><td><code>xhr</code></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = e.<span class="property">loaded</span> / e.<span class="property">total</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="send-data-的参数"><a class="header-anchor" href="#send-data-的参数">¶</a><code>send(data)</code>的参数</h4><p><code>xhr.send(data)</code>的参数data可以是以下几种类型：</p><ul><li><code>ArrayBuffer</code></li><li><code>Blob</code></li><li><code>Document</code></li><li><code>DOMString</code></li><li><code>FormData</code></li><li><code>null</code></li></ul><p>data的值会影响请求头部<code>content-type</code>的默认值。</p><ul><li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li><li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li><li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li></ul><h3 id="4-ajax和js单线程机制"><a class="header-anchor" href="#4-ajax和js单线程机制">¶</a>4.<code>ajax</code>和<code>js</code>单线程机制</h3><p>​在说这个话题之前，需要先了解下<code>js</code>的单线程机制和浏览器的多线程机制：</p><p>​<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></p><p>​       批注版:<a href="https://blog.csdn.net/lin_credible/article/details/40143961#commentBox">JavaScript 运行机制详解：再谈Event Loop</a></p><p>​<em>这里没有黑阮老师的意思，阮老师翻译了很多优质的外文，他的本业是金融，对于计算机知识不够严谨，但对于科普，做简单的了解是足够的，并且阮老师也对博文内的错误做了修改。所以，我们也要明白，要想真正学到东西，还是要去看标准文档，比如<code>mdn web doc</code>，去看学校里的基础课程，任何人的二手知识，只能拿来参考，绝不能作为标准。</em></p><p>​我们都知道，<code>javaScript</code>是一门单线程的语言，但是它运行的环境（这里☞的是浏览器）是多线程的。用当前最流行的<code>Chrome</code>浏览器作为例子。</p><p>有以下几个常驻线程：</p><ul><li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li><li><code>JS</code>引擎线程：负责<code>JS</code>的解析和执行</li><li>定时触发器线程：处理定时事件，比如<code>setTimeout</code>, <code>setInterval</code></li><li>事件触发线程：处理<code>DOM</code>事件</li><li>异步<code>http</code>请求线程：处理<code>http</code>请求</li></ul><p>​        需要注意的是，渲染线程和<code>JS</code>引擎线程是不能同时进行的。渲染线程在执行任务的时候，<code>JS</code>引擎线程会被挂起。因为<code>JS</code>可以操作DOM，若在渲染中<code>JS</code>处理了DOM，浏览器可能就不知所措了。</p><p>另外一个需要提起的是浏览器实现异步的消息队列和事件循环</p><p>​    浏览器有一个主线程用来执行代码，还有一些其他的线程执行比较耗时的操作，比如<code>http</code>请求，定时器等，所有的函数调用都在一个<code>stack</code>里面，主线程会依次执行这个<code>stack</code>里的代码，当遇到一个异步的操作时，异步线程执行异步操作，然后当异步执行完毕，会把回调函数作为一个任务加到一个<strong>消息队列</strong><code>queue</code>里面(实际上，有多个消息队列，这里为了说明做了简化)，浏览器不断的监听着<code>stack</code>，一旦<code>stack</code>被清空。就从队列里取出一个任务加到<code>stack</code>里面，然后主线程执行这个任务。</p><p>​由于<code>js</code>引擎从消息队列里面读取事件任务时不间断的，只要<code>stack</code>清空，就会有新的任务加到里面，如果消息队列里没有任务，就会一直等待，这就是<strong>事件循环</strong><code>Event Loop</code>。</p><p>类似下面代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.<span class="title function_">waitForMessage</span>()) &#123;</span><br><span class="line"> queue.<span class="title function_">processNextMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里插播一道题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">t</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(t));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>答案是 <code>4，3，2，1</code></p><p>​    具体的解释点这里<a href="https://github.com/dwqs/blog/issues/61">从一道题浅说 JavaScript 的事件循环</a>。</p><p>回归正传，</p><p>​当发起一个<code>ajax</code>请求，调用<code>send</code>方法后，浏览器开启新的线程，发起网络请求，<code>js</code>主线程会继续向下执行，当当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 <code>onreadystatechange</code> (当然也可能触发<code>onload</code>, 或者 <code>onerror</code>等等) . 该回调事件并没有被立即执行, 而是被添加到 <code>任务队列</code> 的末尾. 直到<code>js</code>引擎空闲了, <code>任务队列</code> 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 <code>onreadystatechange</code> 事件。</p><h3 id="5-ajax和跨域"><a class="header-anchor" href="#5-ajax和跨域">¶</a>5.<code>ajax</code>和跨域</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">http访问控制</a></p><p>首先要了解什么是跨域，跨域就是因为浏览器的同源策略，造成的访问限制。</p><p>关于解决方案，看下文：</p><p>[<a href="https://segmentfault.com/a/1190000012469713">ajax跨域，这应该是最全的解决方案了</a>](<a href="https://segmentfault.com/a/1190000012469713">https://segmentfault.com/a/1190000012469713</a>)</p><h3 id="6-fetch-api"><a class="header-anchor" href="#6-fetch-api">¶</a>6.<code>fetch api</code></h3><p><code>Fetch API</code> 提供了一个获取资源的接口（包括跨域请求）。任何使用过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 的人都能轻松上手，但新的<code>API</code>提供了更强大和灵活的功能集。并且<code>fetch</code>支持<code>promise</code>语法。</p><p>关于promise点击<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise对象</a></p><p>关于<code>fetch</code>点击 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">Fetch API</a></p><p><code>Fetch</code>有个缺点是不支持进度。</p><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单例子</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">myJson</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myJson);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持请求参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">postData</span>(<span class="params">url, data</span>) &#123;</span><br><span class="line">  <span class="comment">// Default options are marked with *</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="comment">// must match &#x27;Content-Type&#x27; header</span></span><br><span class="line">    <span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span>, <span class="comment">// *default, no-cache, reload, force-cache, only-if-cached</span></span><br><span class="line">    <span class="attr">credentials</span>: <span class="string">&#x27;same-origin&#x27;</span>, <span class="comment">// include, same-origin, *omit</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/4.0 MDN Example&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// *GET, POST, PUT, DELETE, etc.</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>, <span class="comment">// no-cors, cors, *same-origin</span></span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;follow&#x27;</span>, <span class="comment">// manual, *follow, error</span></span><br><span class="line">    <span class="attr">referrer</span>: <span class="string">&#x27;no-referrer&#x27;</span>, <span class="comment">// *client, no-referrer</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>()) <span class="comment">// parses response to JSON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，fetch 不会从服务端发送或接收任何 cookies,如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&#x27;include&#x27;</span>  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>tags</code>:要在不支持的浏览器中使用Fetch，可以使用<a href="https://github.com/github/fetch">Fetch Polyfill</a>。</p><h3 id="7-Axios使用"><a class="header-anchor" href="#7-Axios使用">¶</a>7.<code>Axios</code>使用</h3><p><code>Axios</code> 是一个基于 <code>promise</code> 的 <code>HTTP</code> 库，可以用在浏览器和 <code>node.js</code> 中。如果你不想为了简单的发送<code>ajax</code>请求就要下载庞大的<code>jquery</code>,只有几kb大小的<code>axios</code>是很好的替代产品。</p><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行get 请求</span></span><br><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行post</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行多个并发请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserAccount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserPermissions</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">all</span>([<span class="title function_">getUserAccount</span>(), <span class="title function_">getUserPermissions</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(axios.<span class="title function_">spread</span>(<span class="keyword">function</span> (<span class="params">acct, perms</span>) &#123;</span><br><span class="line">    <span class="comment">// 两个请求现在都执行完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html各种布局整理</title>
      <link href="/posts/e08b183b/"/>
      <url>/posts/e08b183b/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="传统布局"><a class="header-anchor" href="#传统布局">¶</a>传统布局</h3><blockquote><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。</p></blockquote><h4 id="1-圣杯布局"><a class="header-anchor" href="#1-圣杯布局">¶</a>1.圣杯布局</h4><p>圣杯布局就是两边顶宽，中间自适应的三栏布局，中间栏要放在文档流前面一优先渲染。</p><p>很多经典的网页就是这种布局，应用场景很多。</p><p>先看下圣杯布局的<code>dom</code>结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;layout grail&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;left-center-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>这里center 要放在第一个，就是 <strong>中 左 右</strong> 的顺序。</p><p>把“中”放在第一位，是为了首先加载“中”的内容，并且“中”的宽度是自适应的。</p><p>有两种方法，第一种是给左右设置负的<code>margin-left</code>,<a href="http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html#2457812">点击查看负margin的原理</a>。</p><p>简单来说，给左 设置 <code>margin-left:-100%</code>.右设置<code>margin-left:-300px;</code>就把这两个box 拉回上一行，然后给父容器设置左右<code>padding</code> 为 左右的宽度，不过此时左右又受到<code>padding </code>的影响，向中间挤。此时然后再用相对定位把左右调整一下。</p><p><code>css</code>代码如下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grail</span> <span class="selector-class">.left-center-right</span> &#123;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">min-width</span>: <span class="number">304px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.layout</span><span class="selector-class">.grail</span> <span class="selector-class">.left-center-right</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">            <span class="attribute">float</span>: left;</span><br><span class="line">            <span class="attribute">min-height</span>: <span class="number">100px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.layout</span><span class="selector-class">.grail</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">            <span class="attribute">background</span>: yellow;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.layout</span><span class="selector-class">.grail</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: red;</span><br><span class="line">            <span class="attribute">position</span>: relative;</span><br><span class="line">            <span class="attribute">left</span>: -<span class="number">300px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.layout</span><span class="selector-class">.grail</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">            <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: blue;</span><br><span class="line">            <span class="attribute">position</span>: relative;</span><br><span class="line">            <span class="attribute">right</span>: -<span class="number">300px</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>第二种是给父容器设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">   <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">300px</span> <span class="number">0</span> <span class="number">300px</span>;</span><br></pre></td></tr></table></figure><p>圣杯布局的优点：</p><ul><li>主列率先加载</li><li>允许任何列是最高的</li><li>DOM结构简单</li></ul><p>缺点：</p><ul><li>和双飞翼布局相比CSS样式较为复杂</li></ul><h4 id="2-双飞翼布局"><a class="header-anchor" href="#2-双飞翼布局">¶</a>2.<strong>双飞翼布局</strong></h4><p>双飞翼布局源自淘宝UED，第一步和圣杯布局一样，浮动三列，给左右两列设置负外边距；同样会覆盖主列main，双飞翼布局的做法是在主列main后面添加了一个宽度为100%的div，再设置主列main的左右边距，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">          <span class="attribute">float</span>: left;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.main</span>&#123;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">margin-left</span>: <span class="number">110px</span>;</span><br><span class="line">          <span class="attribute">margin-right</span>: <span class="number">210px</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: <span class="number">#01549b</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.left</span>&#123;</span><br><span class="line">          <span class="attribute">float</span>: left;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">          <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: <span class="number">#bd4147</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.right</span>&#123;</span><br><span class="line">          <span class="attribute">float</span>: left;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">          <span class="attribute">background-color</span>: <span class="number">#419641</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>率先加载主列main</li><li>允许任何列是最高的</li><li>CSS样式简单</li></ul><p>缺点：</p><ul><li>和圣杯布局相比DOM结构较为复杂</li></ul><h3 id="现代布局"><a class="header-anchor" href="#现代布局">¶</a>现代布局</h3><h4 id="1-flex-布局"><a class="header-anchor" href="#1-flex-布局">¶</a>1.flex 布局</h4><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a>  阮一峰老师翻译的css-tricks上的文章。</p><p>原文地址：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a></p><p>用<code>Flex</code>布局实现中间自适应，两边固定，很简单。</p><p><code>dom</code>节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">     header</span><br><span class="line"> <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span> </span><br><span class="line">         left</span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span> </span><br><span class="line">         center</span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">          right</span><br><span class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">     footer</span><br><span class="line"> <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>css</code>代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要把父的<code>dom</code>的<code>display</code>设置为<code>flex</code>就行了。</p><h4 id="2-grid-布局"><a class="header-anchor" href="#2-grid-布局">¶</a>2.grid 布局</h4><p><a href="https://www.jianshu.com/p/d183265a8dad">Grid布局指南</a>  也是一篇译文。</p><p>原文地址：<a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-grid-column-row">A Complete Guide to Grid</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;grid&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        left</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;rigth&#x27;</span>&gt;</span></span><br><span class="line">        right</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grid</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> auto;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>资料和代码来源：</p><p><a href="https://zhuanlan.zhihu.com/p/25353247">双飞翼布局与圣杯布局</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-一个所见即所得的文本编辑器</title>
      <link href="/posts/f7575273/"/>
      <url>/posts/f7575273/</url>
      
        <content type="html"><![CDATA[<h3 id="typora"><a class="header-anchor" href="#typora">¶</a>typora</h3><p>​很久很久之前，我以为<code>word</code>就是<strong>所见即所得</strong>的最佳文档编写工具，直到熬夜写完毕业论文，第五次跑到打印店更正格式，来满足范文的正确格式。我突然明白，同学和我说，一定要用<code>pdf</code>来写论文是什么意思了。</p><h4 id="1-真正的所见即所得"><a class="header-anchor" href="#1-真正的所见即所得">¶</a>1.真正的所见即所得</h4><p>​word 功能很强大，也很复杂，是非常非常非常（重要的事情说三遍）专业的文本处理软件，但是，有时我们只想写简单的文档，为毛在自己电脑上看到的和打印出来的不一样呢？这就很令人烦恼。</p><p>​用typora + markdown来写简单的文档是再合适不过了，令人惊奇的的是，typora不想其他的markdown软件，有编辑区和预览区两个部分，它只有编辑区，当你输入一行markdown语法的文本，按下回车，这行文本立刻被渲染成最终展示的效果。</p><p>比如输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 这是三级标题</span></span><br></pre></td></tr></table></figure><p>立刻生成</p><hr><h3 id="这是三级标题"><a class="header-anchor" href="#这是三级标题">¶</a>这是三级标题</h3><hr><p>其他的包括有序，无序列表，表格，图片等都是这样。</p><h3 id="2-数学代码块"><a class="header-anchor" href="#2-数学代码块">¶</a>2.数学代码块</h3><p>​markdown中的数学表达式的语法跟latex的语法一样，习惯latex语法的人可以采用latex的语法编辑数学表达式，但是其中也有一些不同，比如：</p><p>数学表达式的斜体字强制为非斜体字：{\rm [非斜体字的内容]}</p><p>假设要将表达式中的and改为非斜体字的格式，可以采用 {\rm and}实现。</p><p>行内公式可以用$$后输入回车来插入数学公式。（需要在File-&gt;Preferences中勾选“Inline math”）</p><p>这个我现在用的很少，只恨当时再学校的时候不知道这个神器，用word 写数学公式有多痛苦:，用过的都知道。</p><h3 id="3-绘制图表"><a class="header-anchor" href="#3-绘制图表">¶</a>3.绘制图表</h3><p>代码来自官方：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">graph LR</span><br><span class="line">A[Hard edge] --&gt;B(Round edge)</span><br><span class="line">    B --&gt; C&#123;Decision&#125;</span><br><span class="line">    C --&gt;|One| D[Result one]</span><br><span class="line">    C --&gt;|Two| E[Result two]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的是：</p><p><img src="https://wx4.sinaimg.cn/mw1024/bca3c023gy1g1xv6mmn64j20wm07sjrb.jpg" alt="img"></p><p>此外，还支持流程图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line"></span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line"></span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line"></span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line"></span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line"></span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">st-&gt;</span><span class="language-bash">op-&gt;cond</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">cond(yes)-&gt;</span><span class="language-bash">io-&gt;e</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">cond(no)-&gt;</span><span class="language-bash">sub1(right)-&gt;op</span></span><br></pre></td></tr></table></figure><p><img src="https://wx3.sinaimg.cn/mw1024/bca3c023gy1g1xv6mhti3j20wn0hrjrk.jpg" alt="img"></p><p>UML时序图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line"></span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line"></span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line"></span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line"></span><br><span class="line">对象A-&gt;对象B: 你真的好吗</span><br></pre></td></tr></table></figure><p><img src="https://wx1.sinaimg.cn/mw1024/bca3c023gy1g1xv6mhnjkj20wk0b60ss.jpg" alt="img"></p><p>怎么样？是不是很强大。</p><p>学会上面三种语法，简单画图再也不用word，viso,这些占内存的专业软件了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript异步操作进化曲</title>
      <link href="/posts/2b77e8c0/"/>
      <url>/posts/2b77e8c0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>老生常谈，今天也来总结下<code>javaScript</code> 中异步操作的历史。</p></blockquote><p><em>TL;DR</em><br>1.同步和异步区别<br>2.经典的回调函数<br>3.简单明了的<code>promise</code>函数<br>4.未来的主流<code>async</code>函数</p><h2 id="同步和异步的区别"><a class="header-anchor" href="#同步和异步的区别">¶</a>同步和异步的区别</h2><p>异步简单来说就是做一件事时，做到一半可能需要等待系统或服务处理之后才会得到响应和结果，此时可以转去做另一件事，等到获得响应之后在去执行剩下一半的事情。反之同步就是一直等到响应然后接着做事，中间不会跳去做别的事。</p><h2 id="回调函数"><a class="header-anchor" href="#回调函数">¶</a>回调函数</h2><p>就是我们经常用到的回调函数，最开始用 ajax 的时候，会写出下面样子的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;path&quot;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缺点是读起来跳跃性太强，不好跟踪代码。而且在前后依赖的时候，形成回调地狱，一旦修改一个，嵌套的都要改。另外就是无法合并多个异步代码。</p><h2 id="简单明了的promise函数"><a class="header-anchor" href="#简单明了的promise函数">¶</a>简单明了的<code>promise</code>函数</h2><p>Promise 的引入就解决了以上这些问题,首先来看下 Promise 的简单用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">100</span>)；</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data&#x27;</span>, data);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 Promis 通过 then 的链式调用解决了嵌套回调的问题，在用法上 Promise 的构造函数会接受一个 executor 函数，这个函数带有两个参数 resolve 和 reject，两个参数背后其实就是两个函数，而通过 Promise 构造函数创建出来的对象会保存一个 status 属性，resolve 会做的事就是将这个属性从初始化的 pending 转为 resolved，而 reject 则是转为 rejected，同时两个函数都可以接受一个参数，作为之后 then 中回调函数的参数传入，那么在 then 方法中我们可以看到它接收两个参数，第一个就是成功 resolved 之后会调用的回调函数，第二个就是 rejected 的回调函数。<br>这里注意的是，只要状态转为 resolved 或 rejected 之中的其中一个，那么当前 promise 对象就不能再转变状态了。之后不管调 resolve 还是 reject 都会被忽略。<br>另外，上面所说 Promise 是可以支持链式调用的，所以 then 是可以多次调用的，但是因为刚刚所说状态不可转变的问题，所以链式调用每次 then 返回的不是当前的 Promise 对象而是一个新的 Promise 对象，那么第 2 次 then 的状态又是怎么决定的呢，第一次 then 中无论是成功的回调还是失败的回调只要返回了结果就会走下一个 then 中的成功，如果有错误走下一个 then 的失败。</p><p>此外，<code>promise</code> 还有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>();</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>();</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br></pre></td></tr></table></figure><p>这些 api<br><a href="http://es6.ruanyifeng.com/#docs/promise">Promise 对象</a>。</p><p>关于 promise 的实现，可以看下 PromiseA+的原则。下面是一个实现：</p><!-- Get UTF-8 Size (ANSI C) --><!-- Begin --><script src="https://gist.github.com/zzz1220/5fad2985f43f235ed59702b805a7d824.js"></script><!-- End --><h2 id="async-await"><a class="header-anchor" href="#async-await">¶</a>async+await</h2><p>async+await 就是目前为至，异步的最佳解决方案，它同时解决了<br>其实，它是<code>Generator</code>函数的语法糖，之后我会单独写一篇博文介绍<code>Generator</code>函数和它的异步用法。<br>回调地狱<br>并发执行异步，在同一时刻同步返回结果 Promise.all<br>返回值的问题<br>可以实现代码的 try/catch;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bluebird = <span class="built_in">require</span>(<span class="string">&#x27;bluebird&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> read = bluebird.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用async来修饰函数，aysnc需要配await, await只能接promise</span></span><br><span class="line"><span class="comment">// async和await(语法糖) === co + generator</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">r</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> content1 = <span class="keyword">await</span> <span class="title function_">read</span>(<span class="string">&#x27;./2.promise/100.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> content2 = <span class="keyword">await</span> <span class="title function_">read</span>(content1, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> content2;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; <span class="comment">// 如果出错会catch</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数返回的是promise</span></span><br><span class="line"><span class="title function_">r</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;flag&#x27;</span>, data);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);<span class="string">`</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>此外，还有 Generator 实现的，利用<code>co</code>库实现 next 方法嵌套取值执行，本人很少用到，就不详细介绍了。<br>可以看<a href="http://es6.ruanyifeng.com/#docs/generator-async">Generator 函数的异步应用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js变量提升的原理</title>
      <link href="/posts/97277281/"/>
      <url>/posts/97277281/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新版的es6里面，加入了块级作用域<code>let</code>,算是解决了长久以来javascript的变量提升问题。没有<code>let</code>之前，变量只有函数内的作用域和全局作用域（其实全局也是在<code>window</code>这个对象下的），一方面如果忘记加上<code>var</code>,作用域就会提升，另一方面，对变量提升一知半解，导致变量先计算，再赋值，会造成难以预料的问题。</p></blockquote><h2 id="JS引擎的方式"><a class="header-anchor" href="#JS引擎的方式">¶</a>JS引擎的方式</h2><p>因为javaScript是脚本语言，运行在JS虚拟机里面，因此，非常有必要了解一下JS引擎执行JS代码的过程。<br>JS引擎的工作方式就是：1，解析（编译）JS代码，这时候会声明所有的变量，注意这里没有对变量赋值；2，运行，运行的时候会对变量进行赋值。同一个作用域内，变量的声明语句都会被提升到代码的头部，这个就是变量提升，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>因为变量提升后是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a ;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>实际上运行的时候，<code>a</code>还没有被赋值。</p><h2 id="需要注意的地方"><a class="header-anchor" href="#需要注意的地方">¶</a>需要注意的地方</h2><p>1.变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa);</span><br><span class="line">aa =<span class="number">1</span>;  <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure><p>2.function也可以看为变量，会发生提升。但是如果是赋值的形式，则不会</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// 会提升</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// 不会提升，因为这个是赋值语句，运行时，b没有被赋值，因此是undefined</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5到底是啥？</title>
      <link href="/posts/d374f967/"/>
      <url>/posts/d374f967/</url>
      
        <content type="html"><![CDATA[<blockquote><p>现在招聘前端信息上动不动就是熟练掌握h5开发，我有点费解，h5到底是啥？貌似平时也有用到H5的新标签和webSocket等技术，这样算是掌握h5开发了吗？查找资料后简单介绍下这个当红的技术。</p></blockquote><h2 id="html5介绍："><a class="header-anchor" href="#html5介绍：">¶</a>html5介绍：</h2><p>html5是超文本标记语言的第五代。<br>狭义上的HTML5：</p><ol><li>HTML4.0的升级版本</li><li>HTML5+CSS3+新增JS API</li><li>W3C制定的关于HTML技术约定的新规范</li></ol><p>广义上的HTML5：</p><ol><li>HTML5行业的代名词</li><li>行业的技术标准</li><li>当前新技术的代名词</li></ol><p>其实，有些招聘的要求会h5，就是会做那些微信扫码打开的炫酷宣传页面，比如活动页面，祝福贺卡之类的，当然，这些只是h5的一小部分内容.h5包括以下部分：</p><ol><li>新增标签以及属性；</li><li>CSS3的新特性；</li><li>Canvas绘图；</li><li>JavaScript的新增API（如重力感应、HTML5视音频等）；</li><li>移动端。</li></ol><h2 id="新特性介绍："><a class="header-anchor" href="#新特性介绍：">¶</a>新特性介绍：</h2><p>1.新标签：<br/><br>Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。<br/><br>结构性元素主要负责web上下文结构的定义 <br/><br>section：在 web 页面应用中，该元素也可以用于区域的章节描述。<br/><br>header：页面主体上的头部， header 元素往往在一对 body 元素中。<br/><br>footer：页面的底部（页脚），通常会标出网站的相关信息。<br/><br>nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。<br/><br>article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。<br/><br>级块性元素主要完成web页面区域的划分，确保内容的有效分割。<br/><br>aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。<br/><br>figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。<br/><br>code：表示一段代码块。<br/><br>dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。<br/><br>行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。<br/><br>meter：表示特定范围内的数值，可用于工资、数量、百分比等。<br/><br>time：表示时间值。<br/><br>progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。<br/><br>video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。<br/><br>audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。<br/><br>交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。<br/><br>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。<br/><br>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。<br/><br>menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。<br/><br>command：用来处理命令按钮。<br/><br><br/><br>2.CSS3的新特性；<br/><br>CSS3实现圆角（border-radius），阴影（box-shadow）<br/><br>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br/><br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜等等变换<br/><br>增加了更多的CSS选择器  多背景 rgba<br/><br>在CSS3中唯一引入的伪元素是 ::selection.<br/><br>媒体查询，多栏布局，弹性盒子<br/><br>border-image<br/><br>css3动画<br/></p><p>3.canvas绘图：<br/><br>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。<br/><br>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。<br/></p><p>4.JavaScript的新增API：<br/><br>requestAnimationFrame,相比于setInterval,性能更高的动画实现方法。<br/><br>Page Visibility api,页面是否被隐藏，最小化的api接口。<br/><br>Geolocation Api,地理位置。<br/><br>File Api:文件操作。<br/><br>web Worker:后台运行js代码，不会影响页面显示。<br/><br><br/></p><p>5.移动端：<br/><br>借助于响应式开发，和更强大的js引擎，以及新的css实现，语义化，现在网页在移动端也可以表现的更好了。<br/></p><h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2><p>好久没写博客了，东拼西凑又攒了一篇。。。</p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是事件冒泡和事件委托</title>
      <link href="/posts/ae7587e9/"/>
      <url>/posts/ae7587e9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自从有了javaScript这个浏览器端的脚本语言，用户们终于可以告别单调的展示网页了，javaScript给网页带来了新的生命力，网页前端从此变得有趣起来，最主要的，网页上的元素有了事件这个元素，但是关于事件，就不得不提事件冒泡和事件委托这两个关键的知识点。</p></blockquote><h2 id="什么是事件？"><a class="header-anchor" href="#什么是事件？">¶</a>什么是事件？</h2><p>JavaScript与html之间的交互全部都是由事件实现的。事件就是你操作鼠标或者键盘，对网页进行交互，比如你点击一个按钮，就触发了一个<code>onClick</code>事件，你改变input节点内的<code>value</code>,就出发了<code>onChange</code>事件。</p><h2 id="事件流和事件冒泡"><a class="header-anchor" href="#事件流和事件冒泡">¶</a>事件流和事件冒泡</h2><p>你可以把网页想象成几个同心圆，当你点击最中心的圆的时候，也相当与点击外层的几个圆了，所以说，当你点击页面上的一个按钮，就相当于点击了整张页面，会触发这个按钮的所有父节点的click事件，这个就是事件流。但是当时ie和其他的浏览器偏偏要不一样，ie支持的是冒泡流，而网景提出的是捕获流，后来，在w3c组织的统一下，js支持冒泡流和捕获流，但是呢，某些低版本的浏览器（ie6,ie7,ie8）却只支持冒泡流。直接用onClick就是在冒泡阶段添加事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div in=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>对于事件捕获来说，是从外到内的，点击#inner的div，会从window开始捕获，然后是document,html,…,一直到#outer，再到#inner。<br>对于事件冒泡来说，是从内到外的，点击#inner的div，会从#inner开始，到#outer，…，最后是window。</p><p>dom事件流分为三个阶段<br>1.事件捕获。<br>2.处于目标阶段。<br>3.事件冒泡。</p><p>可以分别给dom元素添加事件流事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">            console.log(&#x27;document处于事件捕获阶段&#x27;);</span><br><span class="line">        &#125;, true);// true是捕获阶段，false是冒泡阶段。</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">问题来了，如果不想事件冒泡怎么办？我们点击子节点，不想触发父节点的事件。可以这样做：</span><br></pre></td></tr></table></figure><p>stopPropagation() 方法<br>终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 事件委托  </span><br><span class="line">先说下event对象，这个对象会作为事件的默认参数。</span><br><span class="line">api：</span><br></pre></td></tr></table></figure><p>bubbles返回布尔值，指示事件是否是起泡事件类型。<br>cancelable返回布尔值，指示事件是否可拥可取消的默认动作。<br>currentTarget返回其事件监听器触发该事件的元素。<br>eventPhase返回事件传播的当前阶段。<br>target返回触发此事件的元素（事件的目标节点）。<br>timeStamp返回事件生成的日期和时间。<br>type返回当前 Event 对象表示的事件的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">为啥要进行事件委托，我们都知道dom操作是很花费时间的。与dom节点交互，访问dom节点，非常影响性能。比如要给`ul`下的`li`都添加上click事件，最简单的方法，写个for循环，挨个click就行了，但是这样要多次操纵dom节点。利用事件委托的方式，把`click`事件绑定到`ul`上，因为事件冒泡的存在，会触发`ul`的`click`事件，而且就一次dom操作，那怎么判断点击的是哪一个li呢？这时候上面的event对象就起作用了，event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement。   </span><br><span class="line">这时候我们就拿到了具体点击的dom节点，然后用nodeName获取节点名，在函数内部判断下，就实现把dom操作放在js代码内部来实现了。   </span><br><span class="line">而且这样做还有一点好处就是，新添加的`li`标签不会点击无效，如果直接把事件绑定在`li`上，每添加`li`都要重新绑定事件。   </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul id="ul"><li></li></ul><p>window.onload = function(){<br>　　var oUl = document.getElementById(“ul”);<br>　　oUl.onclick = function(ev){<br>　　　　var ev = ev || window.event;<br>　　　　var target = ev.target || ev.srcElement;<br>　　　　if(target.nodeName.toLowerCase() == ‘li’){<br>　 　　　　　　alert(123);<br>　　　　　　　  alert(target.innerHTML);<br>　　　　}<br>　　}<br>}</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react组件编写非最佳实践</title>
      <link href="/posts/3705f364/"/>
      <url>/posts/3705f364/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果问我2018年最想掌握的东西是什么，第一个是webgl，第二个就是react.js全家桶了。之前也写了一些demo，也不经意间总结了一些东西，可能不是最好的写法，在这里做一些记录。</p></blockquote><h2 id="语法篇"><a class="header-anchor" href="#语法篇">¶</a>语法篇</h2><p>1 灵活使用箭头函数<br>在给组件绑定类似<code>onClick</code>事件的时候,组件内定义的函数里面的this在执行的时候会变成全局，但是es6默认严格模式不允许全局，因此一般会用<code>bind</code>函数绑定this，当然，用箭头函数更简单，因为箭头函数会继承上下文的this。</p><p>2 多用三目表达式和逻辑符号<br>因为jsx语法不支持写if语句,但是我们可以用三目表达式来代替<br><code>&#123;a?&lt;A/&gt;:&lt;B/&gt;&#125;</code><br>但是有时候我们只用判断一次,不需要false情况下做处理，可以用逻辑与<br><code>!!a&amp;&amp;&lt;A/&gt; </code></p><p>3 利用解构赋值解决props过长导致的代码量过大<br>es6 里面在赋值新增加了解构赋值的语法，用起来很方便，例如：<br><code>let [a, b, c] = [1, 2, 3];</code><br><code>let &#123;a,b,c&#125; = &#123;4,5&#125;;\\ c的值是undefined</code><br>在组件里面可以<br><code>const &#123;id,name,title,time&#125; = this.props</code><br>这样可以节约很多代码。</p><p>4 用SFC（Stateless Functional Component）代替一般的纯组件的class写法</p><p>sfc就是这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_handleClick</span>(suggestedUrl, onClick, event) =&gt; &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">RelatedSearch</span> = (<span class="params">&#123; relatedQueries, onClick &#125;</span>) =&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;related-search-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;related-search-title&quot;</span>&gt;</span>Related Searches:<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Layout</span> <span class="attr">x-small</span>=<span class="string">&#123;2&#125;</span> <span class="attr">small</span>=<span class="string">&#123;3&#125;</span> <span class="attr">medium</span>=<span class="string">&#123;4&#125;</span> <span class="attr">padded</span>=<span class="string">&#123;true&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;relatedQueries.map((query, index) =&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">className</span>=<span class="string">&quot;related-search-link&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;(event)</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml">            _handleClick(query.searchQuery, onClick, event)&#125;</span></span><br><span class="line"><span class="language-xml">          key=&#123;index&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          &#123;query.searchText&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">RelatedSearch</span>;</span><br></pre></td></tr></table></figure><p>参数就是props，这种写法比用class写法省略很多东西，没有构造函数，用箭头函数代替render(),因为现在都用redux管理状态，所以有很多纯组件，这种写法可以减少代码量。</p><h2 id="思路篇"><a class="header-anchor" href="#思路篇">¶</a>思路篇</h2><p>1 关于state和props的区别<br>props ：一般用于父组件向子组件通信，在组件之间通信使用。<br>state :  一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等。<br>所以如果是组件本身的状态,不需要用到状态管理比如redux，就用state就行了；一般情况下都是用props的。</p><p>2 尽量是用纯组件，细化组件，提高组件复用<br>状态用redux处理，因为当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，没状态的组件会提高性能。细化组件可以多次使用一个组件，因为react其实就像堆积木一样，组件就是每一块积木，积木越小越灵活。</p><p>3 reducer要灵活<br>首先说一点reducer是实现(state, action) -&gt; newState的纯函数，所以不能有异步操作，需要异步的话<code>yarn add react-thunk</code>，请，当然也有其他的中间件，reducer是可以嵌套的，比如有studentlist的reducer，就可以写个student的函数，处理单个student的数据，在students函数里来处理所有的student的数据。这样避免单个reducer太长，逻辑混杂很难看的。reducer的编写比起组件来说要复杂一点我觉得，写法上也很考验js水平。关于reducer有文章可以参考<a href="https://www.jianshu.com/p/938f8121ba0f">Reducer 最佳实践，Redux 开发最重要的部分</a>。</p><p>未完待续–还要讲的有高阶组件，中间件，异步操作等。</p>]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的会用搜索引擎吗？</title>
      <link href="/posts/c475ea5/"/>
      <url>/posts/c475ea5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天,地球上不同国家的人们都会使用到搜索引擎,或许用来了解新事物,或许用来查找资料文件,当然也有用来下载盗版电影或者游戏的。相信读者可能会对本篇标题不屑一顾,百度一下嘛,谁不会啊？但是,那些高级的搜索技巧你却不一定知道。</p></blockquote><h2 id="选择合适的搜索引擎"><a class="header-anchor" href="#选择合适的搜索引擎">¶</a>选择合适的搜索引擎</h2><p>先说一下为啥我不用百度,不单单是因为“魏泽西事件”,一开始我也会依赖百度的,自从我接触到google后,慢慢的就习惯用google了,为什么不用百度了呢？原因有一下几点：<br>1.搜索结果阉割严重（构建和谐社会必要条件,你懂得）<br>2.因为“gfw”的存在,被墙的网站搜不出来,其中可能包括一些技术站点<br>3.对洋文的收录太少了,不得不承认,在技术上,洋文站点往往更新更全<br>4.百度本身的弊端,烂的不行的百度知道,坑人的竞价排名</p><p>所以,我就抛弃百度,改用google了,但是你知道的,google现在在墙内无法访问,但也不是毫无办法,只要你花费一点时间,就可以突破&quot;gwf&quot;,拥抱freedom了,具体方法不在本文讨论内容里,但是我可以提过一些关键词----“赛风”,“tor”,“lantern”,“自由门”,“vpn”,大部分我都用过,现在正在用&quot;lantern&quot;,如果你有需求,可以用这个软件,具体内容在另外一篇博文里有。</p><h2 id="搜索技巧"><a class="header-anchor" href="#搜索技巧">¶</a>搜索技巧</h2><p>既然说到了google,就介绍一下几个常用的搜索技巧吧！</p><p>1.巧用“与”和“或”<br>“与”很简单，你输入多个关键词,默认情况下,就是与的关系。只有网页同时包含这些关键词,才会被抓取到。<br>“或” 就是在关键词之间加上大写的OR，比如 <code> 关键词1 OR 关键词2</code>这样只要包含任一关键词,都可以被搜索到。</p><p>2.关键词排列<br>比如你想搜索美国苹果,但是可能会搜索到网页的开头是美国,结尾是苹果的页面,很明显,这个不是你真正要查的东西。这时候,你用<code>&quot;美国苹果&quot;</code>,就能搜到真正的美国苹果了。</p><p>3.google hacking<br>这一部分比较多,但是功能非常强大。</p><ul><li>只搜索某个网站的内容  <code>site:example.com</code> ，也可以site:.com，这样,就只会搜到.com域名的网站了。</li><li>限定文件格式  <code>关键词 filetype:[filetype]</code>,filetype可以是pdf,xlsx,doc等文件格式。</li><li>限定标题内容 <code>intitle:关键词</code>,这样,只有标题里面含关键词的才会被搜索出来。</li><li>限定网页正文 <code>intext:关键词</code>或者<code>allintext:关键词</code>,关键词只有在网页正文中。</li><li>限定网页url <code>inurl:关键词</code>，举个栗子,<code>inurl:id=1</code>,很多php站点在这里可以尝试sql注入脱库。<code>inurl:login</code>可以找到一些后台管理的登录页面。</li><li>模糊搜索同义词 <code>~关键词</code>,google可以搜到关键词的同义词的页面。</li><li>通配符 <code>*</code> 你可以用星号 * 指代任何一个词汇。也可以配合上面的第二点<code>&quot;*州市&quot;</code>,猜猜可以搜到啥？</li><li>排除 <code>-</code>  紧挨着关键词之前放减号，表示排除该关键词,比如你想搜索苹果,但不是苹果手机就这样 <code>苹果 -手机</code></li></ul><p>注意：上面这些技巧可以组合使用。</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教练,我想学webSocket</title>
      <link href="/posts/9ceb5dee/"/>
      <url>/posts/9ceb5dee/</url>
      
        <content type="html"><![CDATA[<blockquote><p>html5里,我最感兴趣的两个部分一个是canvas,因为可以实现在页面上画画,基于webgl的技术在未来网页游戏上一定会大放异彩,而另外一部分,就是webSocket了。<strong>但是实际上websocket不是HTML5 的东西</strong>。它是一个协议,归属于IETF。HTML5只是提供了WebSocket API ，两个规范是独立发布的。</p></blockquote><h2 id="什么是webSocket-？"><a class="header-anchor" href="#什么是webSocket-？">¶</a>什么是webSocket ？</h2><p>WebSocket是一种网络通讯协议,目前市面上很多网站都用到了这项技术,比如在线聊天室,在线客服系统,还有一些评论系统,WebIM等。它的特点就是：持久化,实时性,客户端和服务端双向通讯。<br>为什么需要webSocket呢？相信很多程序员都遇到过这样类似的需求----实时的显示物品的价格、股票走势的图标、网页上实现聊天等交互功能。这些需求如果用http协议,只能客户端发请求,服务端返回结果,就需要不停的&quot;轮询&quot;：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率很低,并且浪费资源,需要服务器有很快的处理速度和资源。另外还有一种长连接的方式（long poll）,是阻塞式的ajax,一次请求直到有结果返回才会进行下一次请求,这种方式需要服务器高并发能力。</p><p>而WebSocket就是一个很好的解决方案。</p><h2 id="怎么做到的"><a class="header-anchor" href="#怎么做到的">¶</a>怎么做到的 ?</h2><p>WebSocket基于HTTP协议,借用HTTP的协议完成一部分握手。<br>在握手阶段是一样的。</p><p>下面是WebSocket的握手（如果你经常看htpp的包,就很容易看懂下面的东西）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>这里比HTTP多了几个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这两行会告诉服务器：这是一个WebSocket协议,请用对应的模块处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p>Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的密文,要求服务端必须返回一个对应的加密Sec-WebSocket-Accept应答,否则客户端会抛出Error during WebSocket handshake错误，并关闭连接。<br>Sec-WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。<br>Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft(协议版本),现在都是13。</p><p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>这样就是websocket链接成功,接下来就可以不用request和response愉快的收发数据了。<br>不同的服务端有不同语言的实现方式,而在客户端通常使用js或者其他封装库。</p><p>对比一下HTTP和WebSocket,是这样的~~</p><h3 id="http"><a class="header-anchor" href="#http">¶</a>http:</h3><p>客户端：现在比特币价格多少！<br>服务端：20000刀！<br>10s后<br>客户端：现在比特币价格多少！<br>服务端：18000刀！<br>开始轮询~~~<br>客户端：现在比特币价格多少！<br>0.5s后<br>客户端：现在比特币价格多少！<br>0.5s后<br>客户端：现在比特币价格多少！<br>服务端：19000刀<br>服务端：19000刀<br>服务端：@%#……&amp;@<em>……</em>#*（内心os:累死我了，不干了！）</p><h3 id="WebSocket"><a class="header-anchor" href="#WebSocket">¶</a>WebSocket</h3><p>奥义–websocket链接！！<br>客户端：要是比特币价格变了及时告诉我。<br>服务端：ok，没问题。<br>服务端：惊天大消息，比特币暴跌！<br>客户端：不慌不慌,继续加仓。<br>20s后<br>服务端：涨了！涨了！<br>客户端：还会再涨，加仓，拉满。</p><p>总结就是：<br>1  建立在 TCP 协议之上，服务器端的实现比较容易。<br>2  与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>3  数据格式比较轻量，性能开销小，通信高效。<br>4  可以发送文本，也可以发送二进制数据。<br>5  没有同源限制，客户端可以与任意服务器通信。<br>6  协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p><h2 id="客户端例子"><a class="header-anchor" href="#客户端例子">¶</a>客户端例子</h2><p>在客户端,webSocket使用起来很简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Received Message: &quot;</span> + evt.<span class="property">data</span>);</span><br><span class="line">  ws.<span class="title function_">close</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>初中英语都能看懂是什么意思,就不解释了。<br>另外还有常用的webSocket库,<a href="http://xn--socket-hh4k.io">如socket.io</a>。</p><h3 id="api"><a class="header-anchor" href="#api">¶</a>api:</h3><p>webSocket.readyState readyState属性返回实例对象的当前状态,0:表示正在连接;1,表示连接成功;<br>2，表示连接正在关闭;3，表示连接已经关闭，或者打开连接失败。<br>webSocket.onopen 用于指定连接成功后的回调函数。<br>webSocket.onclose 用于指定连接关闭后的回调函数。<br>webSocket.onmessage 用于指定收到服务器数据后的回调函数。<br>webSocket.send() 用于向服务器发送数据。<br>webSocket.bufferedAmount 表示还有多少字节的二进制数据没有发送出去。<br>webSocket.onerror  用于指定报错时的回调函数。<br>以上api仅简单介绍。详情参照官方<br><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">文档</a></strong></p><h2 id="服务端"><a class="header-anchor" href="#服务端">¶</a>服务端</h2><p>基本上支持网络编程的语言都可以创建webSocket服务,比如java,php,python,node等，网上都有解决方案。<br>下面是用python写的服务端代码,只用到了一些网络模块,方便熟悉webSocket协议内容和步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> simplejson</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">9000</span></span><br><span class="line">MAGIC_STRING = <span class="string">&#x27;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#x27;</span></span><br><span class="line">HANDSHAKE_STRING = <span class="string">&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;Upgrade:WebSocket\r\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;Connection: Upgrade\r\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;Sec-WebSocket-Accept: &#123;1&#125;\r\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;WebSocket-Location: ws://&#123;2&#125;/chat\r\n&quot;</span> \</span><br><span class="line">    <span class="string">&quot;WebSocket-Protocol:chat\r\n\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_data</span>(<span class="params">msg</span>):</span><br><span class="line">    v = <span class="built_in">ord</span>(msg[<span class="number">1</span>]) &amp; <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0x7e</span>:</span><br><span class="line">        p = <span class="number">4</span></span><br><span class="line">    <span class="keyword">elif</span> v == <span class="number">0x7f</span>:</span><br><span class="line">        p = <span class="number">10</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    mask = msg[p:p+<span class="number">4</span>]</span><br><span class="line">    data = msg[p+<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(<span class="built_in">ord</span>(v) ^ <span class="built_in">ord</span>(mask[k%<span class="number">4</span>])) <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(data)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.bind((HOST, PORT))</span><br><span class="line">        sock.listen(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bind error&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, add = sock.accept()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            handshake(conn)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">            conn.close()</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handshake</span>(<span class="params">conn</span>):</span><br><span class="line">    headers = &#123;&#125;</span><br><span class="line">    shake = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> shake</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(shake):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;len error&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    header, data = shake.split(<span class="string">&#x27;\r\n\r\n&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> header.split(<span class="string">&#x27;\r\n&#x27;</span>)[<span class="number">1</span>:]:</span><br><span class="line">        key, value = line.split(<span class="string">&#x27;: &#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        headers[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;Sec-WebSocket-Key&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> headers:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is not websocket, client close.&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> headers</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sec_key = headers[<span class="string">&#x27;Sec-WebSocket-Key&#x27;</span>]</span><br><span class="line">    res_key = base64.b64encode(hashlib.sha1(sec_key + MAGIC_STRING).digest())</span><br><span class="line"></span><br><span class="line">    str_handshke = HANDSHAKE_STRING.replace(<span class="string">&#x27;&#123;1&#125;&#x27;</span>, res_key).replace(<span class="string">&#x27;&#123;2&#125;&#x27;</span>, HOST + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(PORT))</span><br><span class="line">    <span class="built_in">print</span> str_handshke</span><br><span class="line"></span><br><span class="line">    conn.send(str_handshke)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    conn.send(<span class="string">&#x27;%c%c%s&#x27;</span> % (<span class="number">0x81</span>, <span class="number">6</span>, <span class="string">&#x27;suren1&#x27;</span>))</span><br><span class="line">    msg = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    msg = parse_data(msg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;msg : &#x27;</span> + msg)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    conn.send(<span class="string">&#x27;%c%c%s&#x27;</span> % (<span class="number">0x81</span>, <span class="number">6</span>, <span class="string">&#x27;suren2&#x27;</span>))</span><br><span class="line">    msg = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    msg = parse_data(msg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;msg : &#x27;</span> + msg)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    conn.send(<span class="string">&#x27;%c%c%s&#x27;</span> % (<span class="number">0x81</span>, <span class="number">6</span>, <span class="string">&#x27;suren3&#x27;</span>))</span><br><span class="line">    msg = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    msg = parse_data(msg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;msg : &#x27;</span> + msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p>参考：<br>（1）<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a><br>（2）<a href="https://www.zhihu.com/question/20215561">知乎–WebSocket 是什么原理？为什么可以实现持久连接？</a><br>（3）<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">webApi接口|mdn</a></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript柯里化</title>
      <link href="/posts/2b34be88/"/>
      <url>/posts/2b34be88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直对函数式编程非常感兴趣，因此时常会留意下关于函数式编程的概念，之前一直听到柯里化，但是只闻其名，知道他可以接受一个函数，并且返回值也是函数，返回的函数可以继续接受参数运算，直到出发原始函数的执行条件，并没有认真研究，今天就花点时间好好研究下，看看如何写出符合柯里化（curry）的函数，</p></blockquote><h3 id="什么是柯里化？"><a class="header-anchor" href="#什么是柯里化？">¶</a>什么是柯里化？</h3><p>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。</p><blockquote><p>柯里化允许我们把函数与传递给它的参数结合，产生一个新的函数。[引自《JavaScript语言精髓》，第43页 柯里化]</p></blockquote><p>通俗一点，就是之前的函数是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而柯里化后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curryAdd = <span class="title function_">curry</span>(add)</span><br></pre></td></tr></table></figure><p>要计算的时候，就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">cuurryAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>看上去很不错吧，在函数式编程里面，简化了代码的复杂性，代码量变小，看起来更加优雅，可以达到延迟计算的方法，不断传入参数，最后执行；另外，根据网上的说法:</p><blockquote><p>函数柯里化允许和鼓励你分隔复杂功能变成更小更容易分析的部分。这些小的逻辑单元显然是更容易理解和测试的，然后你的应用就会变成干净而整洁的组合，由一些小单元组成的组合。</p></blockquote><p>关于这一点，我还在自己品味。是不是可以省略多参函数的参数，带入具体的函数以提供更细分的方法调用？</p><h3 id="通用的柯里化方法："><a class="header-anchor" href="#通用的柯里化方法：">¶</a>通用的柯里化方法：</h3><p>[代码引自《JavaScript: Novice to Ninja》，第319页 A General Curry Function]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fixedArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    args = fixedArgs.<span class="title function_">concat</span>([].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">    <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">运行方法：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divider</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line">reciprocal = <span class="title function_">curry</span>(divider,<span class="number">1</span>);</span><br><span class="line"><span class="title function_">reciprocal</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>执行reciprocal(2)相当于执行curry(divider,1)(2)。然后看curry方法通过[].slice方法去掉了传入的第一个参数，即function divider(x,y) {return x/y;}，之后保留了变量x=1并返回一个新的函数，这是一个匿名函数，同时传入变量y=2，这时fixedArgs.concat([].slice.call(arguments))将之前传入的变量x和现在传入的变量y重新组合成一个数组，最后执行函数divider，这时使用的参数是组合后的[1,2]。整个curry方法主要工作就是组织两次传入的参数，然后通过apply方式调用函数。</p><p>最后，如果利用es6的新特性的话，就可以一行写出一个柯里化函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">currySingle</span> = fn =&gt; (<span class="function">(<span class="params">limit</span>) =&gt;</span> judgeCurry = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.<span class="property">length</span> &gt;= limit ? fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args) : <span class="function">(<span class="params">...args2</span>) =&gt;</span> judgeCurry.<span class="title function_">apply</span>(<span class="literal">null</span>, args.<span class="title function_">concat</span>(args2)))(fn.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><p>摘自[一行写出javascript函数式编程中的curry] <a href="https://segmentfault.com/a/1190000008248646">https://segmentfault.com/a/1190000008248646</a></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
